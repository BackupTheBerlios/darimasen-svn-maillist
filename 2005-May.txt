From darimasen-svn-admin at lists.berlios.de  Sun May  1 01:58:56 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Sun, 1 May 2005 01:58:56 +0200
Subject: [Darimasen-svn] r65 - in trunk: . src
Message-ID: <200504302358.j3UNwu0F004457@sheep.berlios.de>

Author: sudrien
Date: 2005-05-01 01:58:31 +0200 (Sun, 01 May 2005)
New Revision: 65

Modified:
   trunk/TODO
   trunk/src/iconmodes.cpp
Log:
minimal AppDir Support

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-04-30 21:21:46 UTC (rev 64)
+++ trunk/TODO	2005-04-30 23:58:31 UTC (rev 65)
@@ -5,7 +5,7 @@
 add a routine to update tab numbers when tabs get deleted.
 
 evaluate the " Gtk-CRITICAL **: gtk_widget_event: assertion `WIDGET_REALIZED_FOR_EVENT (widget, event)' failed" messages
-Full Folder & Icon context menus.
+Full Folder context menu.
 Keyboard navigation of menus (Alt+1 opens root menu, Alt+2 opens first child, etc)
 
 Move, copy, delete of files needs more checking
@@ -13,13 +13,12 @@
 move, copy, delete of folder
 move, copy of folder contents
 
-Traditional List and detail views
+detail view
 
 
 Would like to do:
 
 limiting DaMenu expansion (preserve window width for long paths) - by shortening menu names
-AppDir Support
 Create new folder
 Ron <Rds> mentioned that Rox will be moving for ~/Choices to ~/.choices - should probably support that, or check both locations
 use existing thumbnails / create new thumbnails (a la ROX)

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-04-30 21:21:46 UTC (rev 64)
+++ trunk/src/iconmodes.cpp	2005-04-30 23:58:31 UTC (rev 65)
@@ -6,18 +6,22 @@
 
 void DaIconModes::proto_icon::run() const{
 
-  // double checking the file exists
-  Glib::RefPtr<const Gnome::Vfs::FileInfo> info;
-  Gnome::Vfs::Handle read_handle;
-  try{
-    read_handle.open( path + FileName, Gnome::Vfs::OPEN_READ);
-    info = read_handle.get_file_info(
-      Gnome::Vfs::FILE_INFO_GET_MIME_TYPE );
+  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(path + FileName);
+
+  if (!x->uri_exists()){
+    std::cout << "Is not a file - ";
+    x = Gnome::Vfs::Uri::create(path);
+    if (!x->uri_exists()){
+      std::cout << "is not an appdir either. Bogus.\n";
+      }
+    else {
+      std::cout << "it is a appdir.\n";
+    Glib::spawn_command_line_async(path + "AppRun");
+
+    parent->parent->set_message(path + " was executed.");
+	return;
+      }
     }
-  catch(const Gnome::Vfs::exception& ex){
-    std::cout << "Does not exist.\n";
-    return;
-    }
 
   Gnome::Vfs::Handle exec_handle;
 
@@ -221,7 +225,11 @@
         sigc::mem_fun(*this, &DaIconModes::proto_icon::unlinkify)));
 
 
-    parent->prompt.popup(event->button, event->time);
+
+ // Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create( path + ".DirIcon");
+    if (FileMime != "AppDir"){
+      parent->prompt.popup(event->button, event->time);
+      }
     }
   }
 
@@ -235,8 +243,18 @@
   path = getPath;
   parent = &getParent;
 
-  icon = parent->getIcon(getFile->get_mime_type());
+  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
+    getPath + ".DirIcon");
+  if (x->uri_exists()){
+    icon = Gdk::Pixbuf::create_from_file(getPath + ".DirIcon");
+    FileMime = "AppDir";
+    }
+  else {
 
+    icon = parent->getIcon(getFile->get_mime_type());
+    FileMime = getFile->get_mime_type();
+    }
+
   FileName = getFile->get_name();
 
   if (getFile->get_name().length() > 25){
@@ -252,8 +270,8 @@
   ShortFileName = getFile->get_name();
   }
 
-  FileMime = getFile->get_mime_type();
 
+
   guint size = getFile->get_size();
   if(size < 1024)
     FileSize = int2ustr(size) + " B";
@@ -675,6 +693,15 @@
   if (info->get_type() != Gnome::Vfs::FILE_TYPE_DIRECTORY){
     iconlist[slotsUsed++] = new proto_icon(*this, parent->get_history(position), info);
     }
+  else {
+    Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
+      parent->get_history(position) + info->get_name() + slash + ".DirIcon");
+      if (x->uri_exists()){
+        //std::cout<< x->get_path() << "\n";
+        iconlist[slotsUsed++] = new proto_icon(
+          *this, parent->get_history(position) + info->get_name() + slash, info);
+        }
+    }
 
   return true;
   }



From darimasen-svn-admin at lists.berlios.de  Fri May  6 07:51:56 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Fri, 6 May 2005 07:51:56 +0200
Subject: [Darimasen-svn] r69 - in trunk: . src
Message-ID: <200505060551.j465pup2012659@sheep.berlios.de>

Author: sudrien
Date: 2005-05-06 07:51:43 +0200 (Fri, 06 May 2005)
New Revision: 69

Modified:
   trunk/TODO
   trunk/src/damenu.cpp
   trunk/src/darimasen.cpp
   trunk/src/darimasen.h
   trunk/src/iconmodes.cpp
   trunk/src/main.cpp
Log:
prompts for directory operations

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/TODO	2005-05-06 05:51:43 UTC (rev 69)
@@ -8,7 +8,7 @@
 Full Folder context menu.
 Keyboard navigation of menus (Alt+1 opens root menu, Alt+2 opens first child, etc)
 
-Move, copy, delete of files needs more checking
+Move, copy, delete of files needs more checking (or at least feedback)
 
 move, copy, delete of folder
 move, copy of folder contents
@@ -20,8 +20,8 @@
 
 limiting DaMenu expansion (preserve window width for long paths) - by shortening menu names
 Create new folder
-Ron <Rds> mentioned that Rox will be moving for ~/Choices to ~/.choices - should probably support that, or check both locations
 use existing thumbnails / create new thumbnails (a la ROX)
+files in APPDIR root folder are not appdirs - check if file name is in path...
 
 
 version 0.0.9
@@ -33,11 +33,6 @@
  
 ---
 
- at commit 11 -- With the ROX / Gnome-vfsmm work done, most of Ron's <Rds> code is gone. This would include the AppDir test. However, appdirs would never end up showing up in the main window, so this is not a huge loss as of yet. His test was for AppRun within the directory - it would require testing for that file's existance, then notifying that it is an executable and needs a unique icon.
-
----
-
-
 -----------------------------------------------
 
 --version 0.1.0 (beta?)
@@ -49,7 +44,8 @@
 
 --version 0.1.1 and onwards
 
-Drag and drop. 
-Re-port to windows
+Drag and drop - into menu, between tabs, copy/paste/link popup, multiple selection
+Re-port to windows?
+Consider DnD holding box - a "Drop stack". 
 
 

Modified: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/src/damenu.cpp	2005-05-06 05:51:43 UTC (rev 69)
@@ -67,7 +67,7 @@
         Glib::ustring SubSubCount;
         if(ext == ""){
           subdir = Gtk::manage( new Gtk::MenuItem(refFileInfo->get_name() + slash + " "));
-         // subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
+          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
 
           subdir->signal_button_press_event().connect(
             sigc::bind<Glib::ustring,guint,bool>(
@@ -78,8 +78,8 @@
           }
         else{
           subdir = Gtk::manage( new Gtk::MenuItem(ext + slash + refFileInfo->get_name() + slash + " "));
+          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
 
-
           subdir->signal_button_press_event().connect(
             sigc::bind<Glib::ustring,guint,bool>(
               sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
@@ -92,9 +92,10 @@
           Gtk::Label * SubSubLabel = Gtk::manage(new class Gtk::Label(SubSubCount + " \342\226\272",1,0.5));
           SubSubLabel->show();
           Gtk::MenuItem * subsubdir = Gtk::manage( new Gtk::MenuItem(*SubSubLabel));
+
           subsubdir->set_right_justified();
 
-
+          subsubdir->set_events(Gdk::BUTTON_RELEASE_MASK);
           subsubdir->signal_button_release_event().connect(
             sigc::bind<int, Glib::ustring, Glib::ustring>(
               sigc::mem_fun(*this, &DarimasenMenu::SpecialMenuForPath),
@@ -236,11 +237,191 @@
 
 /**********************/
 
-    void DarimasenMenu::copy(Glib::ustring path){}
-    void DarimasenMenu::move(Glib::ustring path){}
-    void DarimasenMenu::link(Glib::ustring path){}
-    void DarimasenMenu::unlinkify(Glib::ustring path){}
+void DarimasenMenu::copy(Glib::ustring path){
 
+  Gtk::Dialog copyDialogue;
+  Gtk::Button * cancelbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+  Gtk::Button * okbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+  Gtk::RadioButton::Group _RadioBGroup_radiobutton4;
+  Gtk::RadioButton * radiobutton4 = Gtk::manage(
+    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy Directory to ... (cp .)"));
+  Gtk::RadioButton * radiobutton5 = Gtk::manage(
+    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy files in directory to ... (cp *)"));
+  Gtk::RadioButton * radiobutton6 = Gtk::manage(
+    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy everything in directory to ... (cp -R *)"));
+  Gtk::Entry * entry2 = Gtk::manage(new class Gtk::Entry());
+  cancelbutton2->set_flags(Gtk::CAN_FOCUS);
+  cancelbutton2->set_flags(Gtk::CAN_DEFAULT);
+  okbutton2->set_flags(Gtk::CAN_FOCUS);
+
+  copyDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+  radiobutton4->set_flags(Gtk::CAN_FOCUS);
+  radiobutton5->set_flags(Gtk::CAN_FOCUS);
+  radiobutton6->set_flags(Gtk::CAN_FOCUS);
+  entry2->set_flags(Gtk::CAN_FOCUS);
+  entry2->set_editable(true);
+  entry2->set_text(path);
+  copyDialogue.get_vbox()->pack_start(*radiobutton4, Gtk::PACK_SHRINK, 0);
+  copyDialogue.get_vbox()->pack_start(*radiobutton5, Gtk::PACK_SHRINK, 0);
+  copyDialogue.get_vbox()->pack_start(*radiobutton6, Gtk::PACK_SHRINK, 0);
+  copyDialogue.get_vbox()->pack_start(*entry2, Gtk::PACK_SHRINK, 0);
+  copyDialogue.set_title("Copy (Directory)");
+  copyDialogue.set_modal(true);
+
+  copyDialogue.set_resizable(true);
+  copyDialogue.add_action_widget(*cancelbutton2, -6);
+  copyDialogue.add_action_widget(*okbutton2, -5);
+  copyDialogue.show_all_children();
+
+  switch(copyDialogue.run()){
+    case(Gtk::RESPONSE_OK):{
+      std::cout << path << "moved\n";
+      return;
+      }
+    default:{
+      std::cout << path << "not moved\n";
+      return;
+      }
+    }
+  }
+
+/**********************/
+
+void DarimasenMenu::move(Glib::ustring path){
+
+  Gtk::Dialog moveDialogue;
+  Gtk::Button * cancelbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+  Gtk::Button * okbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+  Gtk::RadioButton::Group _RadioBGroup_radiobutton1;
+  Gtk::RadioButton * radiobutton1 = Gtk::manage(new class Gtk::RadioButton(
+    _RadioBGroup_radiobutton1, "Move " + path + " to ... (mv .)"));
+  Gtk::RadioButton * radiobutton2 = Gtk::manage(new class Gtk::RadioButton(
+    _RadioBGroup_radiobutton1, "Move files in directory to... (mv *)"));
+  Gtk::RadioButton * radiobutton3 = Gtk::manage(new class Gtk::RadioButton(
+    _RadioBGroup_radiobutton1, "Move everything in directory to... (mv -R *)"));
+  Gtk::Entry * entry1 = Gtk::manage(new class Gtk::Entry());
+  cancelbutton1->set_flags(Gtk::CAN_FOCUS);
+  cancelbutton1->set_flags(Gtk::CAN_DEFAULT);
+  okbutton1->set_flags(Gtk::CAN_FOCUS);
+  moveDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+  radiobutton1->set_flags(Gtk::CAN_FOCUS);
+  radiobutton2->set_flags(Gtk::CAN_FOCUS);
+  radiobutton3->set_flags(Gtk::CAN_FOCUS);
+  entry1->set_flags(Gtk::CAN_FOCUS);
+  entry1->set_editable(true);
+  entry1->set_text(path);
+  moveDialogue.get_vbox()->pack_start(*radiobutton1, Gtk::PACK_SHRINK, 0);
+  moveDialogue.get_vbox()->pack_start(*radiobutton2, Gtk::PACK_SHRINK, 0);
+  moveDialogue.get_vbox()->pack_start(*radiobutton3, Gtk::PACK_SHRINK, 0);
+  moveDialogue.get_vbox()->pack_start(*entry1, Gtk::PACK_SHRINK, 0);
+  moveDialogue.set_title("Move (Directory)");
+  moveDialogue.set_modal(true);
+  moveDialogue.set_resizable(true);
+  moveDialogue.property_destroy_with_parent().set_value(true);
+  moveDialogue.add_action_widget(*cancelbutton1, -6);
+  moveDialogue.add_action_widget(*okbutton1, -5);
+  moveDialogue.show_all_children();
+
+  switch(moveDialogue.run()){
+    case(Gtk::RESPONSE_OK):{
+      std::cout << path << "moved\n";
+      return;
+      }
+    default:{
+      std::cout << path << "not moved\n";
+      return;
+      }
+    }
+  }
+
+
+/**********************/
+
+void DarimasenMenu::link(Glib::ustring path){
+  Gtk::Dialog linkDialogue;
+  Gtk::Button * cancelbutton3 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+  Gtk::Button * okbutton3 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+  Gtk::Label * label1 = Gtk::manage(new class Gtk::Label("Create link to "+ path +" at ..."));
+  Gtk::Entry * entry3 = Gtk::manage(new class Gtk::Entry());
+  cancelbutton3->set_flags(Gtk::CAN_FOCUS);
+  cancelbutton3->set_flags(Gtk::CAN_DEFAULT);
+  okbutton3->set_flags(Gtk::CAN_FOCUS);
+  linkDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+  label1->set_alignment(0,0.5);
+  label1->set_padding(2,2);
+  label1->set_justify(Gtk::JUSTIFY_LEFT);
+  label1->set_line_wrap(true);
+  label1->set_use_markup(false);
+  label1->set_selectable(false);
+  entry3->set_flags(Gtk::CAN_FOCUS);
+  entry3->set_visibility(true);
+  entry3->set_editable(true);
+  entry3->set_text(path);
+  entry3->set_activates_default(false);
+  linkDialogue.get_vbox()->pack_start(*label1, Gtk::PACK_SHRINK, 0);
+  linkDialogue.get_vbox()->pack_start(*entry3, Gtk::PACK_SHRINK, 0);
+  linkDialogue.set_title("Link (Directory)");
+  linkDialogue.set_modal(true);
+  linkDialogue.set_resizable(true);
+  linkDialogue.property_destroy_with_parent().set_value(true);
+  linkDialogue.add_action_widget(*cancelbutton3, -6);
+  linkDialogue.add_action_widget(*okbutton3, -5);
+
+  linkDialogue.show_all_children();
+
+  switch(linkDialogue.run()){
+    case(Gtk::RESPONSE_OK):{
+      std::cout << "link created " + path << "\n";
+      return;
+      }
+    default:{
+      std::cout << "No link created " + path << "\n";
+      return;
+      }
+    }
+  }
+
+/**********************/
+
+
+void DarimasenMenu::unlinkify(Glib::ustring path){
+  Gtk::Dialog unlinkifyDialogue;
+  Gtk::Button * cancelbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+  Gtk::Button * okbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+  Gtk::Label * label2 = Gtk::manage(
+    new class Gtk::Label("Are you sure you want to delete " + path + " and its contents?"));
+  cancelbutton4->set_flags(Gtk::CAN_FOCUS);
+  cancelbutton4->set_flags(Gtk::CAN_DEFAULT);
+  okbutton4->set_flags(Gtk::CAN_FOCUS);
+  unlinkifyDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+  label2->set_alignment(0,0.5);
+  label2->set_padding(2,2);
+  label2->set_justify(Gtk::JUSTIFY_LEFT);
+  label2->set_line_wrap(true);
+  unlinkifyDialogue.get_vbox()->pack_start(*label2, Gtk::PACK_SHRINK, 0);
+  unlinkifyDialogue.set_title("Delete (Directory)");
+  unlinkifyDialogue.set_modal(true);
+  unlinkifyDialogue.property_window_position().set_value(Gtk::WIN_POS_NONE);
+  unlinkifyDialogue.set_resizable(true);
+  unlinkifyDialogue.property_destroy_with_parent().set_value(true);
+  unlinkifyDialogue.add_action_widget(*cancelbutton4, -6);
+  unlinkifyDialogue.add_action_widget(*okbutton4, -5);
+  unlinkifyDialogue.show_all_children();
+
+  switch(unlinkifyDialogue.run()){
+    case(Gtk::RESPONSE_OK):{
+      std::cout << "Deleted " + path << "\n";
+      return;
+      }
+    default:{
+      std::cout << "No deletion " + path << "\n";
+      return;
+      }
+    }
+  }
+
     void DarimasenMenu::bookmark(Glib::ustring path){}
 
 /**********************/

Modified: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/src/darimasen.cpp	2005-05-06 05:51:43 UTC (rev 69)
@@ -35,8 +35,6 @@
 
 
   DarimasenMenuContainer->remove();
-
- 
   DaMenu = Gtk::manage(new class DarimasenMenu(get_history(n), *this, n));
   DarimasenMenuContainer->add(*DaMenu);
 
@@ -59,23 +57,23 @@
     Tabber->set_show_tabs(true);
 
 
-  Gtk::Image * xed = Gtk::manage(
-    new Gtk::Image("/usr/share/icons/hicolor/16x16/stock/generic/stock_close.png"));
+  Gtk::Image * xed = 
+    new Gtk::Image("/usr/share/icons/hicolor/16x16/stock/generic/stock_close.png");
   xed->show();
 
   Gtk::Label * tabNum;
 
   if ( get_history(pos) == slash)
-    tabNum = Gtk::manage(new Gtk::Label(slash + " "));
+    tabNum = new Gtk::Label(slash + " ");
   else if ( get_history(pos) == (getenv("HOME") + slash))
-    tabNum = Gtk::manage(new Gtk::Label("~ "));
+    tabNum = new Gtk::Label("~ ");
   else
-    tabNum = Gtk::manage(new Gtk::Label(
-      get_history(pos).substr(get_history(pos).rfind(slash,get_history(pos).length() - 2  ) + 1)));
+    tabNum = new Gtk::Label(
+      get_history(pos).substr(get_history(pos).rfind(slash,get_history(pos).length() - 2  ) + 1));
 
 
-  Gtk::HBox * arrangement= Gtk::manage(new Gtk::HBox()) ;
-  Gtk::Button * closeButton = Gtk::manage( new Gtk::Button());
+  Gtk::HBox * arrangement= new Gtk::HBox() ;
+  Gtk::Button * closeButton = new Gtk::Button();
 
   closeButton->add(*xed);
   closeButton->set_relief(Gtk::RELIEF_NONE); 
@@ -99,7 +97,7 @@
   MainEventBox->show();
 
   DaIconModes * foo;
-  foo = Gtk::manage(new class DaIconModes(  pos, *this));
+  foo = new class DaIconModes(pos, *this);
 
   if ( IconModeList.size() == pos ){
     IconModeList.push_back(foo);
@@ -112,7 +110,7 @@
     EventBoxList[pos] = MainEventBox;
     }
 
-  Gtk::ScrolledWindow * MainScroller = Gtk::manage(new Gtk::ScrolledWindow);
+  Gtk::ScrolledWindow * MainScroller = new Gtk::ScrolledWindow;
   MainScroller->show();
   MainScroller->set_shadow_type(Gtk::SHADOW_NONE);
   MainScroller->add(*MainEventBox);
@@ -184,11 +182,13 @@
   mode = 0;
 
   try{
-    set_icon_from_file( "/usr/share/icons/hicolor/48x48/apps/darimasen.png"  );
+     windowIcon = Gdk::Pixbuf::create_from_file("/usr/share/icons/hicolor/48x48/apps/darimasen.png");
+    set_icon(windowIcon);
     }
   catch(const Glib::Error) {
     try{
-      set_icon_from_file( "../pixmaps/48x48/darimasen.png"  );
+      windowIcon = Gdk::Pixbuf::create_from_file("../pixmaps/48x48/darimasen.png");
+      set_icon(windowIcon);
       }
     catch(const Glib::Error) {}
     }
@@ -317,11 +317,19 @@
   delete CompactMenu;
   delete CompactMenuContainer;
 
+  windowIcon.clear();
   for (int i=0; i < IconModeList.size(); i++){
      delete IconModeList[i];
      delete EventBoxList[i];
      }
 
+// had no effect
+//  for(int i=0; i < unsizedImg.size(); i++){
+    //mimeList[i].clear();
+ //   unsizedImg[i].clear();
+  //  }
+
+
   hide();
   }
 

Modified: trunk/src/darimasen.h
===================================================================
--- trunk/src/darimasen.h	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/src/darimasen.h	2005-05-06 05:51:43 UTC (rev 69)
@@ -113,16 +113,22 @@
   void fPrintHist();
   void fChangeIconMode();
 
+Glib::RefPtr<Gdk::Pixbuf> windowIcon;
 
-
   std::vector< class DaIconModes* > IconModeList;
   std::vector< class Gtk::EventBox* > EventBoxList;
   short mode;
 
   std::vector< std::vector<Glib::ustring> > history;
 
+
+
+
 public:
 
+  std::vector <Glib::ustring> mimeList;
+  std::vector < Glib::RefPtr<Gdk::Pixbuf> > unsizedImg;
+
   Darimasen(std::vector<Glib::ustring>);
   ~Darimasen();
 

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/src/iconmodes.cpp	2005-05-06 05:51:43 UTC (rev 69)
@@ -256,7 +256,6 @@
     FileMime = "AppDir";
     }
   else {
-
     icon = parent->getIcon(getFile->get_mime_type());
     FileMime = getFile->get_mime_type();
     }
@@ -292,7 +291,7 @@
 /**********************/
 
 DaIconModes::proto_icon::~proto_icon(){
-  std::cout << "proto deleted";
+  icon.clear();
   }
 
 /**********************/
@@ -652,13 +651,12 @@
 
 Glib::RefPtr<Gdk::Pixbuf> DaIconModes::getIcon(Glib::ustring mimeGiven){
   int i;
-  static std::vector <Glib::ustring> mimeList;
-  static std::vector < Glib::RefPtr<Gdk::Pixbuf> > unsizedImg;
 
 
-  for(i = 0; i< mimeList.size(); i++){
-    if( mimeGiven == mimeList[i] ){
-      return unsizedImg[i];
+
+  for(i = 0; i< parent->mimeList.size(); i++){
+    if( mimeGiven == parent->mimeList[i] ){
+      return parent->unsizedImg[i];
       }
     }
    // pic doesn't exist.
@@ -683,13 +681,13 @@
      }
     }
 
-  mimeList.push_back(mimeGiven);
+  parent->mimeList.push_back(mimeGiven);
 
   Glib::RefPtr<Gdk::Pixbuf> xe = Gdk::Pixbuf::create_from_file(ico);
 
-  unsizedImg.push_back(xe);
+  parent->unsizedImg.push_back(xe);
 
-  return unsizedImg[i]; 
+  return parent->unsizedImg[i]; 
   }
 
 /**********************/
@@ -746,7 +744,7 @@
   if (tmp)
     delete tmp; // actually DisposableTable, but segfaulted otherwise
 
-  Gtk::Table * DisposableTable = new Gtk::Table((filesAtPath)/IconsHigh+1,IconsHigh);
+  Gtk::Table * DisposableTable = new Gtk::Table((slotsUsed)/IconsHigh+1,IconsHigh);
   add(*DisposableTable);
 
   int y_pos = 0;
@@ -825,6 +823,8 @@
 
 DaIconModes::~DaIconModes(){
 
+  while( slotsUsed > 0)
+    delete iconlist[--slotsUsed];
   }
 
 /**********************/

Modified: trunk/src/main.cpp
===================================================================
--- trunk/src/main.cpp	2005-05-04 04:25:27 UTC (rev 68)
+++ trunk/src/main.cpp	2005-05-06 05:51:43 UTC (rev 69)
@@ -90,10 +90,9 @@
   for(int i =0; i< path.size();i++)
       std::cout << path[i] <<  "\n";
 
-  Darimasen * window = new Darimasen(path);
-  Gtk::Main::run(*window); 
+  Darimasen window(path);
+  Gtk::Main::run(window); 
 
-  delete window;
   return 0;
   }
 



From darimasen-svn-admin at lists.berlios.de  Fri May  6 23:29:52 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Fri, 6 May 2005 23:29:52 +0200
Subject: [Darimasen-svn] r70 - in trunk: . pixmaps pixmaps/scalable src
Message-ID: <200505062129.j46LTqmW018579@sheep.berlios.de>

Author: sudrien
Date: 2005-05-06 23:29:49 +0200 (Fri, 06 May 2005)
New Revision: 70

Added:
   trunk/darimasen.desktop
Modified:
   trunk/Makefile.am
   trunk/TODO
   trunk/pixmaps/Makefile.am
   trunk/pixmaps/scalable/Makefile.am
   trunk/src/iconmodes.cpp
   trunk/src/supplimental.cpp
   trunk/src/supplimental.h
Log:
metwo's execution patch, darimasen.desktop

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/Makefile.am	2005-05-06 21:29:49 UTC (rev 70)
@@ -1,6 +1,15 @@
-# generated 2004/9/10 11:30:35 CEST by nick at frisbee.mnc.ch.(none)
-# using glademm V2.6.0_cvs
-
 SUBDIRS = pixmaps src
 
-EXTRA_DIST = AUTHORS TODO README configure 
+
+
+#/usr/share/applications/darimasen.desktop
+
+
+appdir = \
+        $(datadir)/applications
+
+app_DATA = \
+        darimasen.desktop
+
+
+EXTRA_DIST = AUTHORS TODO README configure $(app_DATA)

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/TODO	2005-05-06 21:29:49 UTC (rev 70)
@@ -18,6 +18,7 @@
 
 Would like to do:
 
+set unreadable folders insensitive, etc.
 limiting DaMenu expansion (preserve window width for long paths) - by shortening menu names
 Create new folder
 use existing thumbnails / create new thumbnails (a la ROX)

Added: trunk/darimasen.desktop
===================================================================
--- trunk/darimasen.desktop	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/darimasen.desktop	2005-05-06 21:29:49 UTC (rev 70)
@@ -0,0 +1,9 @@
+[Desktop Entry]
+Encoding=UTF-8
+Name=Darimasen file manager
+Name[ja]=???????????????
+Comment=Folders are not files!
+Icon=darimasen.svg
+Exec=darimasen
+Type=Application
+Categories=Application;System; 

Modified: trunk/pixmaps/Makefile.am
===================================================================
--- trunk/pixmaps/Makefile.am	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/pixmaps/Makefile.am	2005-05-06 21:29:49 UTC (rev 70)
@@ -2,7 +2,7 @@
 	scalable 48x48
 
 appsicondir = \
-        $(datadir)/pixmaps/
+        $(datadir)/pixmaps
 
 appsicon_DATA = \
         darimasenInfo.svg

Modified: trunk/pixmaps/scalable/Makefile.am
===================================================================
--- trunk/pixmaps/scalable/Makefile.am	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/pixmaps/scalable/Makefile.am	2005-05-06 21:29:49 UTC (rev 70)
@@ -1,5 +1,5 @@
 appsicondir = \
-	$(datadir)/icons/hicolor/scalable/apps/
+	$(datadir)/icons/hicolor/scalable/apps
 
 appsicon_DATA = \
 	darimasen.svg \

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/src/iconmodes.cpp	2005-05-06 21:29:49 UTC (rev 70)
@@ -36,7 +36,7 @@
     exec_handle.open(exec, Gnome::Vfs::OPEN_READ);
 
     exec += " \""  + path + FileName + "\"";
-    Glib::spawn_command_line_async(exec);
+    goruncommand(exec,path);
 
     parent->parent->set_message(exec + " was run.");
     return;
@@ -50,7 +50,7 @@
     exec = exec.substr(0, exec.rfind("_"));
     exec_handle.open(exec, Gnome::Vfs::OPEN_READ);
     exec += " \""  + path + FileName + "\"";
-    Glib::spawn_command_line_async(exec);
+    goruncommand(exec,path);
 
     parent->parent->set_message(exec + " was run.");
     return;
@@ -61,7 +61,7 @@
   try{
     if (Gnome::Vfs::Mime::can_be_executable(FileMime)){
       parent->parent->set_message( "Running " + path + FileName);
-      Glib::spawn_command_line_async( path + FileName );
+      goruncommand(exec,path);
       return;
       }
    }

Modified: trunk/src/supplimental.cpp
===================================================================
--- trunk/src/supplimental.cpp	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/src/supplimental.cpp	2005-05-06 21:29:49 UTC (rev 70)
@@ -43,3 +43,12 @@
   }
 
 /**********************/
+
+void goruncommand(Glib::ustring exec, Glib::ustring path){
+//execute a command in the correct working directory
+    Glib::ArrayHandle<std::string> cmd_args = Glib::shell_parse_argv(exec);
+    Glib::spawn_async(path, cmd_args, Glib::SPAWN_SEARCH_PATH);
+
+  }
+  
+/**********************/ 

Modified: trunk/src/supplimental.h
===================================================================
--- trunk/src/supplimental.h	2005-05-06 05:51:43 UTC (rev 69)
+++ trunk/src/supplimental.h	2005-05-06 21:29:49 UTC (rev 70)
@@ -13,6 +13,7 @@
 Glib::ustring int2ustr(int);
 Glib::ustring underscoreSafe(Glib::ustring);
 Glib::ustring getchoicesdir();
+void goruncommand(Glib::ustring, Glib::ustring);
 
 /**********************/
 



From darimasen-svn-admin at lists.berlios.de  Mon May  9 13:07:47 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Mon, 9 May 2005 13:07:47 +0200
Subject: [Darimasen-svn] r71 - trunk/src
Message-ID: <200505091107.j49B7l18012435@sheep.berlios.de>

Author: metwo
Date: 2005-05-09 13:07:36 +0200 (Mon, 09 May 2005)
New Revision: 71

Modified:
   trunk/src/firsttime.cpp
   trunk/src/firsttime.h
Log:
Fixed typos and layout of firsttime dialog

Modified: trunk/src/firsttime.cpp
===================================================================
--- trunk/src/firsttime.cpp	2005-05-06 21:29:49 UTC (rev 70)
+++ trunk/src/firsttime.cpp	2005-05-09 11:07:36 UTC (rev 71)
@@ -11,21 +11,19 @@
    image1 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-dialog-question"), Gtk::IconSize(6)));
    label1 = Gtk::manage(new class Gtk::Label("It looks like this is your first time\n"
 		"running Darimasen.\n\n"
-		"It would be a good time to set up\n"
+		"This is a good time to set up\n"
 		"some default \"Run Actions\"\n\n"
 		"Simply replace the wildcard (*)\n"
-		"with your prefered program."));
+		"with your preferred program."));
    hbox1 = Gtk::manage(new class Gtk::HBox(false, 0));
-   label2 = Gtk::manage(new class Gtk::Label("Text Files:"));
-   label3 = Gtk::manage(new class Gtk::Label("Music FIles:"));
-   label4 = Gtk::manage(new class Gtk::Label("Video Files:\n"
-		""));
-   label5 = Gtk::manage(new class Gtk::Label("Image files:\n"
-		""));
-   entry1 = Gtk::manage(new class Gtk::Entry());
-   entry2 = Gtk::manage(new class Gtk::Entry());
-   entry3 = Gtk::manage(new class Gtk::Entry());
-   entry4 = Gtk::manage(new class Gtk::Entry());
+   textlabel = Gtk::manage(new class Gtk::Label("Text Files:"));
+   musiclabel = Gtk::manage(new class Gtk::Label("Music Files:"));
+   videolabel = Gtk::manage(new class Gtk::Label("Video Files:"));
+   imagelabel = Gtk::manage(new class Gtk::Label("Image Files:"));
+   textentry = Gtk::manage(new class Gtk::Entry());
+   musicentry = Gtk::manage(new class Gtk::Entry());
+   videoentry = Gtk::manage(new class Gtk::Entry());
+   imageentry = Gtk::manage(new class Gtk::Entry());
    table1 = Gtk::manage(new class Gtk::Table(2, 2, false));
    hbox2 = Gtk::manage(new class Gtk::HBox(false, 0));
    vbox1 = Gtk::manage(new class Gtk::VBox(false, 0));
@@ -44,30 +42,31 @@
    hbox1->pack_start(*image1, Gtk::PACK_SHRINK, 0);
    hbox1->pack_start(*label1);
 
-   entry1->set_flags(Gtk::CAN_FOCUS);
-   entry1->set_text("* \"$@\"");
+   textlabel->set_alignment(0.96,0.5);
 
-   entry2->set_flags(Gtk::CAN_FOCUS);
-   entry2->set_text("* \"$@\"");
+   textentry->set_flags(Gtk::CAN_FOCUS);
+   textentry->set_text("* \"$@\"");
 
-   entry3->set_flags(Gtk::CAN_FOCUS);
-   entry3->set_text("* \"$@\"");
+   musicentry->set_flags(Gtk::CAN_FOCUS);
+   musicentry->set_text("* \"$@\"");
 
+   videoentry->set_flags(Gtk::CAN_FOCUS);
+   videoentry->set_text("* \"$@\"");
 
-   entry4->set_flags(Gtk::CAN_FOCUS);
-   entry4->set_text("* \"$@\"");
+   imageentry->set_flags(Gtk::CAN_FOCUS);
+   imageentry->set_text("* \"$@\"");
 
    table1->set_border_width(2);
    table1->set_row_spacings(5);
    table1->set_col_spacings(4);
-   table1->attach(*label2, 0, 1, 0, 1, Gtk::FILL);
-   table1->attach(*label3, 0, 1, 1, 2, Gtk::FILL);
-   table1->attach(*label4, 0, 1, 2, 3, Gtk::FILL);
-   table1->attach(*label5, 0, 1, 3, 4, Gtk::FILL);
-   table1->attach(*entry1, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*entry2, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*entry3, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*entry4, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL);
+   table1->attach(*textlabel, 0, 1, 0, 1, Gtk::FILL);
+   table1->attach(*musiclabel, 0, 1, 1, 2, Gtk::FILL);
+   table1->attach(*videolabel, 0, 1, 2, 3, Gtk::FILL);
+   table1->attach(*imagelabel, 0, 1, 3, 4, Gtk::FILL);
+   table1->attach(*textentry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL);
+   table1->attach(*musicentry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL);
+   table1->attach(*videoentry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL);
+   table1->attach(*imageentry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL);
    hbox2->pack_start(*table1);
    vbox1->pack_start(*hbox1);
    vbox1->pack_start(*hbox2);
@@ -93,8 +92,8 @@
 Glib::ustring choicesdir="/.choices";
 
 
-  if ( entry1->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + entry1->get_text() + "\n";
+  if ( textentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
+    Glib::ustring command = "#! /bin/sh\nexec " + textentry->get_text() + "\n";
     try {
       Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/text"));
       Gnome::Vfs::Handle write_handle;
@@ -105,8 +104,8 @@
     catch(const Gnome::Vfs::exception) {}
 }
 
-  if ( entry2->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + entry2->get_text() + "\n";
+  if ( musicentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
+    Glib::ustring command = "#! /bin/sh\nexec " + musicentry->get_text() + "\n";
     try {
       Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/audio"));
       Gnome::Vfs::Handle write_handle;
@@ -117,8 +116,8 @@
     catch(const Gnome::Vfs::exception) {}
 }
 
-  if ( entry3->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + entry3->get_text() + "\n";
+  if ( videoentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
+    Glib::ustring command = "#! /bin/sh\nexec " + videoentry->get_text() + "\n";
     try {
       Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/video"));
       Gnome::Vfs::Handle write_handle;
@@ -129,8 +128,8 @@
     catch(const Gnome::Vfs::exception) {}
 }
 
-  if ( entry4->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + entry4->get_text() + "\n";
+  if ( imageentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
+    Glib::ustring command = "#! /bin/sh\nexec " + imageentry->get_text() + "\n";
     try {
       Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/image"));
       Gnome::Vfs::Handle write_handle;

Modified: trunk/src/firsttime.h
===================================================================
--- trunk/src/firsttime.h	2005-05-06 21:29:49 UTC (rev 70)
+++ trunk/src/firsttime.h	2005-05-09 11:07:36 UTC (rev 71)
@@ -24,14 +24,14 @@
         class Gtk::Image * image1;
         class Gtk::Label * label1;
         class Gtk::HBox * hbox1;
-        class Gtk::Label * label2;
-        class Gtk::Label * label3;
-        class Gtk::Label * label4;
-        class Gtk::Label * label5;
-        class Gtk::Entry * entry1;
-        class Gtk::Entry * entry2;
-        class Gtk::Entry * entry3;
-        class Gtk::Entry * entry4;
+        class Gtk::Label * textlabel;
+        class Gtk::Label * imagelabel;
+        class Gtk::Label * videolabel;
+        class Gtk::Label * musiclabel;
+        class Gtk::Entry * textentry;
+        class Gtk::Entry * imageentry;
+        class Gtk::Entry * videoentry;
+        class Gtk::Entry * musicentry;
         class Gtk::Table * table1;
         class Gtk::HBox * hbox2;
         class Gtk::VBox * vbox1;



From darimasen-svn-admin at lists.berlios.de  Sat May 14 19:18:43 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Sat, 14 May 2005 19:18:43 +0200
Subject: [Darimasen-svn] r72 - in trunk: . pixmaps pixmaps/16x16 src
Message-ID: <200505141718.j4EHIh9f003286@sheep.berlios.de>

Author: metwo
Date: 2005-05-14 19:18:39 +0200 (Sat, 14 May 2005)
New Revision: 72

Added:
   trunk/pixmaps/16x16/
   trunk/pixmaps/16x16/Makefile.am
   trunk/pixmaps/16x16/darimasen.png
   trunk/src/optionsManager.cpp
   trunk/src/optionsManager.h
Modified:
   trunk/AUTHORS
   trunk/Makefile.am
   trunk/autogen.sh
   trunk/configure.in
   trunk/pixmaps/Makefile.am
   trunk/src/Makefile.am
   trunk/src/damenu.cpp
   trunk/src/damenu.h
   trunk/src/darimasen.cpp
   trunk/src/darimasen.h
   trunk/src/firsttime.cpp
   trunk/src/firsttime.h
   trunk/src/iconmodes.cpp
   trunk/src/iconmodes.h
   trunk/src/main.cpp
   trunk/src/main.h
   trunk/src/supplimental.cpp
   trunk/src/supplimental.h
Log:
Added the beginnings of session management, safer selecting as proposed 
by neuron on the forums, optimizations all over.


Modified: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/AUTHORS	2005-05-14 17:18:39 UTC (rev 72)
@@ -17,8 +17,9 @@
 (http://regexxer.sourceforge.net/) - their autogen.sh was consuted,
 at least. ^_^
 
-Some code was generated by glademm.
+Portions of the code were generated by glademm.
 
-Includes files from BinReloc-1.5:  
-(http://autopackage.org/docs/binreloc/)
+Portions of the code were stolen directly from the glibmm examples,
+ and brutalized until they did our bidding.
 
+

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/Makefile.am	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,15 +1,9 @@
 SUBDIRS = pixmaps src
 
-
-
-#/usr/share/applications/darimasen.desktop
-
-
 appdir = \
         $(datadir)/applications
 
 app_DATA = \
         darimasen.desktop
 
-
 EXTRA_DIST = AUTHORS TODO README configure $(app_DATA)

Modified: trunk/autogen.sh
===================================================================
--- trunk/autogen.sh	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/autogen.sh	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,6 +1,4 @@
 #!/bin/sh
-# generated 2004/9/10 11:30:35 CEST by nick at frisbee.mnc.ch.(none)
-# using glademm V2.6.0_cvs
 
 export WANT_AUTOMAKE="1.7"
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/configure.in	2005-05-14 17:18:39 UTC (rev 72)
@@ -22,4 +22,9 @@
 
 
 
-AC_OUTPUT([Makefile src/Makefile pixmaps/Makefile pixmaps/48x48/Makefile pixmaps/scalable/Makefile])
+AC_OUTPUT([Makefile \
+        src/Makefile \
+        pixmaps/Makefile \
+        pixmaps/16x16/Makefile \
+        pixmaps/48x48/Makefile \
+        pixmaps/scalable/Makefile])

Added: trunk/pixmaps/16x16/Makefile.am
===================================================================
--- trunk/pixmaps/16x16/Makefile.am	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/pixmaps/16x16/Makefile.am	2005-05-14 17:18:39 UTC (rev 72)
@@ -0,0 +1,12 @@
+appsicondir = \
+	$(datadir)/icons/hicolor/16x16/apps
+
+appsicon_DATA = \
+        darimasen.png
+
+EXTRA_DIST = \
+        $(appsicon_DATA)
+
+MAINTAINERCLEANFILES = \
+        Makefile.in
+

Added: trunk/pixmaps/16x16/darimasen.png
===================================================================
(Binary files differ)


Property changes on: trunk/pixmaps/16x16/darimasen.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/pixmaps/Makefile.am
===================================================================
--- trunk/pixmaps/Makefile.am	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/pixmaps/Makefile.am	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,5 +1,5 @@
 SUBDIRS = \
-	scalable 48x48
+	scalable 16x16 48x48
 
 appsicondir = \
         $(datadir)/pixmaps

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/Makefile.am	2005-05-14 17:18:39 UTC (rev 72)
@@ -7,16 +7,16 @@
 	supplimental.cpp \
         firsttime.cpp \
 	main.cpp \
-	damenu.cpp 
-
+	damenu.cpp \
+        optionsManager.cpp
 noinst_HEADERS = \
 	darimasen.h \
 	iconmodes.h \
 	supplimental.h \
         firsttime.h \
 	main.h \
-	damenu.h 
-
+	damenu.h \
+        optionsManager.h
 AM_CXXFLAGS = -I../.. @PKG_CFLAGS@
 
 darimasen_LDADD = -lpthread @LIBS@ @PKG_LIBS@ 

Modified: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/damenu.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,11 +1,9 @@
-
 /* Darimasen - damenu.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
 
 /**********************/
 
 #include "damenu.h"
 
-
 /**********************/
 
 
@@ -457,15 +455,15 @@
 
   depth = 0;
 
-  Glib::ustring shortpath = path; //home = getenv("HOME");
+  Glib::ustring shortpath = path; //home = Glib::get_home_dir();
 
   parent = &Myparent;
   
   int startPos = 0 , i = 0;
 
 
-  if ( path.find(getenv("HOME")) != Glib::ustring::npos ){
-    shortpath.replace(0,((Glib::ustring)getenv("HOME")).length(),"~");
+  if ( path.find(Glib::get_home_dir()) != Glib::ustring::npos ){
+    shortpath.replace(0,((Glib::ustring)Glib::get_home_dir()).length(),"~");
     }
 
   while ( (shortpath.find(slash,startPos) != Glib::ustring::npos) ) {
@@ -547,7 +545,7 @@
           subdir2->signal_button_press_event().connect(
             sigc::bind<Glib::ustring,guint,bool>(
               sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                getenv("HOME"),pos,false));
+                Glib::get_home_dir(),pos,false));
 
     Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
     MenuArray[0]->attach(*sep, 0 ,1, 2, 3);

Modified: trunk/src/damenu.h
===================================================================
--- trunk/src/damenu.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/damenu.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,28 +1,15 @@
-/* Darimasen - darimasen.h - Copyright (C) 2004 - 2005 Sudrien, GPL
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
+/* Darimasen - damenu.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
 
-
 #ifndef DAMENU_H
 #define DAMENU_H
 
+/**********************/
 
-#include <gtkmm.h>
+#include "main.h"
 #include "darimasen.h"
-#include <iostream>
 
+/**********************/
+
   class DarimasenMenu : public Gtk::MenuBar {
 
     class Darimasen * parent;

Modified: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/darimasen.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -3,14 +3,12 @@
 /**********************/
 
 #include "darimasen.h"
-#include <iostream>
 
-
 /**********************/
 
 // anything prefixed with 'f' corresponds with a button. 'nuff said.
 void Darimasen::fNewTab(){
-  set_history(Tabber->get_n_pages(), getenv("HOME") + slash);
+  set_history(Tabber->get_n_pages(), Glib::get_home_dir() + slash);
   addTab(Tabber->get_n_pages());
 
   }
@@ -65,7 +63,7 @@
 
   if ( get_history(pos) == slash)
     tabNum = new Gtk::Label(slash + " ");
-  else if ( get_history(pos) == (getenv("HOME") + slash))
+  else if ( get_history(pos) == (Glib::get_home_dir() + slash))
     tabNum = new Gtk::Label("~ ");
   else
     tabNum = new Gtk::Label(
@@ -292,6 +290,9 @@
     set_history(i,paths[i]);
     addTab(Tabber->get_n_pages());
     }
+
+
+myOptions = new optionsQuery(Glib::get_home_dir() + getchoicesdir() + "/Darimasen/Options");
  }
 
 /**********************/
@@ -328,8 +329,8 @@
     //mimeList[i].clear();
  //   unsizedImg[i].clear();
   //  }
+  delete myOptions;
 
-
   hide();
   }
 

Modified: trunk/src/darimasen.h
===================================================================
--- trunk/src/darimasen.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/darimasen.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -20,46 +20,14 @@
 
 /**********************/
 
-#include <gtkmm/window.h>
-#include <stack>
-#include <gtkmm/box.h>
-#include <gtkmm/toolbar.h>
-#include <gtkmm/separatortoolitem.h>
-#include <gtkmm/toggletoolbutton.h>
-#include <gtkmm/toolbutton.h>
-#include <gtkmm/menubar.h>
-#include <gtkmm/paned.h>
-#include <gtkmm/scrolledwindow.h>
-#include <gtkmm/eventbox.h>
-#include <gtkmm/statusbar.h>
-#include <gtkmm/menu.h>
-#include <gtkmm/stock.h>
-
-
 #include "main.h"
-#include <sys/types.h>
-#include <gtkmm/eventbox.h>
-
-#include <gtkmm/menuitem.h>
+#include <sys/types.h>
+#include <gtkmm/menutoolbutton.h>
 
-
-#include "supplimental.h"
-#include <iostream>
-#include <gtkmm/scrollbar.h>
-#include <gtkmm/treemodel.h>
-#include <gtkmm/treestore.h>
-#include <gtkmm/treeview.h>
-#include <gtkmm/notebook.h>
-
-#include <gdkmm/pixbufloader.h>
-
-#include <gtkmm/layout.h>
-
-#include "iconmodes.h"
+#include "optionsManager.h"
 #include "damenu.h"
-#include <gtkmm/menutoolbutton.h>
+#include "iconmodes.h"
 
-
 /**********************/
 
 class Darimasen : public Gtk::Window {
@@ -121,9 +89,9 @@
 
   std::vector< std::vector<Glib::ustring> > history;
 
+class optionsQuery * myOptions;
 
 
-
 public:
 
   std::vector <Glib::ustring> mimeList;

Modified: trunk/src/firsttime.cpp
===================================================================
--- trunk/src/firsttime.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/firsttime.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,5 +1,7 @@
 /* Darimasen - firsttime.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
 
+/**********************/
+
 #include "firsttime.h"
 
 /**********************/
@@ -10,7 +12,7 @@
    okbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
    image1 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-dialog-question"), Gtk::IconSize(6)));
    label1 = Gtk::manage(new class Gtk::Label("It looks like this is your first time\n"
-		"running Darimasen.\n\n"
+		"running Darimasen (and have not used ROX).\n\n"
 		"This is a good time to set up\n"
 		"some default \"Run Actions\"\n\n"
 		"Simply replace the wildcard (*)\n"
@@ -95,7 +97,7 @@
   if ( textentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
     Glib::ustring command = "#! /bin/sh\nexec " + textentry->get_text() + "\n";
     try {
-      Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/text"));
+      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/text"));
       Gnome::Vfs::Handle write_handle;
       write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
       write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
@@ -107,7 +109,7 @@
   if ( musicentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
     Glib::ustring command = "#! /bin/sh\nexec " + musicentry->get_text() + "\n";
     try {
-      Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/audio"));
+      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/audio"));
       Gnome::Vfs::Handle write_handle;
       write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
       write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
@@ -119,7 +121,7 @@
   if ( videoentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
     Glib::ustring command = "#! /bin/sh\nexec " + videoentry->get_text() + "\n";
     try {
-      Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/video"));
+      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/video"));
       Gnome::Vfs::Handle write_handle;
       write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
       write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
@@ -131,7 +133,7 @@
   if ( imageentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
     Glib::ustring command = "#! /bin/sh\nexec " + imageentry->get_text() + "\n";
     try {
-      Glib::ustring exec1 = (getenv("HOME") +  (Glib::ustring)(choicesdir + "/MIME-types/image"));
+      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/image"));
       Gnome::Vfs::Handle write_handle;
       write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
       write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);

Modified: trunk/src/firsttime.h
===================================================================
--- trunk/src/firsttime.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/firsttime.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -4,14 +4,6 @@
 #define FIRSTTIME_H
 
 #include "main.h"
-#include <gtkmm/dialog.h>
-#include <gtkmm/button.h>
-#include <gtkmm/buttonbox.h>
-#include <gtkmm/image.h>
-#include <gtkmm/label.h>
-#include <gtkmm/box.h>
-#include <gtkmm/entry.h>
-#include <gtkmm/table.h>
 
 /**********************/
 

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/iconmodes.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,5 +1,7 @@
 /* Darimasen - iconmodes.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
 
+/**********************/
+
 #include "iconmodes.h"
 
 /**********************/
@@ -27,7 +29,7 @@
 
 //check the choices dir
 Glib::ustring choicesdir = getchoicesdir();
-Glib::ustring exec = getenv("HOME");
+Glib::ustring exec = Glib::get_home_dir();
   try{
     exec += choicesdir;
     exec += "/MIME-types/";
@@ -38,7 +40,7 @@
     exec += " \""  + path + FileName + "\"";
     goruncommand(exec,path);
 
-    parent->parent->set_message(exec + " was run.");
+    parent->parent->set_message(FileName + " was run as " + FileMime);
     return;
 
     }
@@ -52,7 +54,7 @@
     exec += " \""  + path + FileName + "\"";
     goruncommand(exec,path);
 
-    parent->parent->set_message(exec + " was run.");
+    parent->parent->set_message(FileName + " was run as " + FileMime.substr(0,FileMime.find("/")));
     return;
     }
   catch(const Gnome::Vfs::exception& ex){
@@ -77,12 +79,12 @@
   switch(dialog.run()) {
     case(Gtk::RESPONSE_OK):
       {
-        Glib::ustring exec = getenv("HOME");
+        Glib::ustring exec = Glib::get_home_dir();
 	exec += choicesdir;
         exec += "/MIME-types/text";
         exec += " \""  + path + FileName + "\"";
         Glib::spawn_command_line_async(exec);
-        parent->parent->set_message(exec + " was opened as a text file.");
+        parent->parent->set_message(FileName + " was run as a text file.");
         return;
         }
       break;
@@ -111,7 +113,7 @@
 
   Glib::ustring choicesdir = getchoicesdir();
   Gnome::Vfs::Handle exec_handle;
-  Glib::ustring exec = getenv("HOME");
+  Glib::ustring exec = Glib::get_home_dir();
   try{
     exec += choicesdir;
     exec += "/MIME-types/text";
@@ -119,7 +121,7 @@
     exec += " \""  + path + FileName + "\"";
     Glib::spawn_command_line_async(exec);
 
-    parent->parent->set_message(exec + " was run.");
+    parent->parent->set_message(exec + " was run as text");
     return;
     }
   catch(const Gnome::Vfs::exception& ex){}
@@ -249,9 +251,8 @@
   path = getPath;
   parent = &getParent;
 
-  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
-    getPath + ".DirIcon");
-  if (x->uri_exists()){
+  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create( getPath + ".DirIcon");
+  if (x->uri_exists() && Glib::str_has_suffix(getPath,getFile->get_name() + slash)){
     icon = Gdk::Pixbuf::create_from_file(getPath + ".DirIcon");
     FileMime = "AppDir";
     }
@@ -433,9 +434,9 @@
 
 void DaIconModes::ChooseActionDialogue::GetCurrentAction(Glib::ustring mimeType){
 
-  Glib::ustring choicesdir = getchoicesdir();
-  Glib::ustring contents, exec1 = getenv("HOME");
-  exec1 += choicesdir;
+  //Glib::ustring choicesdir = getchoicesdir();
+  Glib::ustring contents, exec1 = Glib::get_home_dir();
+  exec1 += getchoicesdir();
   exec1 += (Glib::ustring)("/MIME-types/");
   exec1 += mimeType;
 
@@ -467,7 +468,7 @@
     command += "\n";
 
     try {
-      Glib::ustring exec1 = getenv("HOME");
+      Glib::ustring exec1 = Glib::get_home_dir();
       Glib::ustring choicesdir = getchoicesdir();
       exec1 += choicesdir;
       exec1 += (Glib::ustring)("/MIME-types/");
@@ -705,7 +706,6 @@
     Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
       parent->get_history(position) + info->get_name() + slash + ".DirIcon");
       if (x->uri_exists()){
-        //std::cout<< x->get_path() << "\n";
         iconlist[slotsUsed++] = new proto_icon(
           *this, parent->get_history(position) + info->get_name() + slash, info);
         }
@@ -755,12 +755,20 @@
       switch(mode){
         case 0: {
           Sidecon * tmpSidecon = new Sidecon(*iconlist[i]);
-          DisposableTable->attach( *tmpSidecon, x_pos, x_pos+1, y_pos, y_pos+1,Gtk::FILL, Gtk::FILL, 4, 4);
+          Gtk::Alignment * alignment1 = Gtk::manage(
+            new class Gtk::Alignment(Gtk::ALIGN_LEFT, Gtk::ALIGN_CENTER, 0, 0));
+          alignment1->add(*tmpSidecon);
+          DisposableTable->attach( *alignment1, x_pos, x_pos+1, y_pos, y_pos+1,
+            Gtk::FILL, Gtk::FILL , 4, 4);
             }
           break;
         case 1: {
           Listview * tmpListview = new Listview(*iconlist[i]);
-          DisposableTable->attach( *tmpListview, x_pos, x_pos+1, y_pos, y_pos+1,Gtk::FILL, Gtk::FILL, 4, 4);
+          Gtk::Alignment * alignment1 = Gtk::manage(
+            new class Gtk::Alignment(Gtk::ALIGN_LEFT, Gtk::ALIGN_CENTER, 0, 0));
+          alignment1->add(*tmpListview);
+          DisposableTable->attach( *alignment1, x_pos, x_pos+1, y_pos, y_pos+1,
+            Gtk::FILL, Gtk::FILL, 4, 4);
             }
           break;
         }

Modified: trunk/src/iconmodes.h
===================================================================
--- trunk/src/iconmodes.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/iconmodes.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -4,13 +4,8 @@
 #define ICONMODES_H
 
 
+#include "main.h"
 #include "darimasen.h"
-#include <libgnomevfsmm.h>
-#include <gtkmm/table.h>
-#include <gdkmm/pixbuf.h>
-#include <gtkmm/entry.h>
-#include <gtkmm/messagedialog.h>
-#include <gtkmm/separator.h>
 
 /**********************/
 

Modified: trunk/src/main.cpp
===================================================================
--- trunk/src/main.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/main.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,9 +1,12 @@
- /* Darimasen - main.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
+/* Darimasen - main.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
    
+/**********************/
   
 #include "main.h"
+
 #include "firsttime.h"
-  
+#include "darimasen.h"
+
 /**********************/
   
 int main(int argc, char *argv[])
@@ -13,7 +16,7 @@
 
   // check for mime definitions. 
   { 
-    Glib::ustring fuz = getenv("HOME") ;
+    Glib::ustring fuz = Glib::get_home_dir() ;
     Glib::ustring altfuz = fuz;
     fuz += "/Choices";
     Glib::RefPtr<Gnome::Vfs::Uri> fuzz = Gnome::Vfs::Uri::create(fuz);
@@ -30,20 +33,25 @@
     //check which choices dir to use, use .choices if Choices isn't there      
     if (!fuzz->uri_exists()){
    	fuz = altfuz;
-        
     }
 
-   fuz += "/MIME-types";
-   Glib::RefPtr<Gnome::Vfs::Uri> fuz2 = Gnome::Vfs::Uri::create(fuz);
+   // make actions folder if needed
+   Glib::RefPtr<Gnome::Vfs::Uri> fuz2 = Gnome::Vfs::Uri::create(fuz + "/MIME-types");
     if (!fuz2->uri_exists()){
-      gnome_vfs_make_directory(fuz.c_str(),493);
-      dialog1_glade window;
+      gnome_vfs_make_directory((fuz + "/MIME-types").c_str(),493);
+      dialog1_glade window; 
       Gtk::Main::run(window); 
       }
+    
+
+   // make our own settings folder if needed
+   Glib::RefPtr<Gnome::Vfs::Uri> fuz3 = Gnome::Vfs::Uri::create(fuz + "/Darimasen");
+    if (!fuz3->uri_exists()){
+      gnome_vfs_make_directory((fuz + "/Darimasen").c_str(),493);
+      }
     }
 
 
-
   std::vector<Glib::ustring> path;
 
   for( int i=1; i < argc; i++){
@@ -80,12 +88,9 @@
     }
 
   if(path.empty())
-  #ifdef WIN32
-  path.push_back(getenv("USERPROFILE") + slash);
-  #else
-  path.push_back(getenv("HOME") + slash);
-  #endif
+    path.push_back(Glib::get_home_dir() + slash);
 
+
   std::cout << "Tabs opened should be for:\n";
   for(int i =0; i< path.size();i++)
       std::cout << path[i] <<  "\n";

Modified: trunk/src/main.h
===================================================================
--- trunk/src/main.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/main.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -5,12 +5,20 @@
 
 /**********************/
 
-#include <gtkmm/main.h>
-#include <glibmm/ustring.h>
+#include <vector>
+#include <iostream>
 #include <libgnomevfsmm.h>
-#include <vector>
+#include <gtkmm.h>
+
+#include "supplimental.h"
+
+/**********************
+
 #include "darimasen.h"
-
+#include "optionsManager.h"
+#include "supplimental.h"
+#include "iconmodes.h"
+#include "damenu.h"
 /**********************/
 
 #ifdef WIN32

Added: trunk/src/optionsManager.cpp
===================================================================
--- trunk/src/optionsManager.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/optionsManager.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -0,0 +1,57 @@
+/* Darimasen - optionsManager.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
+
+/**********************/
+
+#include "optionsManager.h"
+
+/**********************/
+
+void optionsQuery::DumpParser::on_start_element(Glib::Markup::ParseContext&,
+                                  const Glib::ustring&,
+                                  const AttributeMap&  attributes){
+  for(AttributeMap::const_iterator p = attributes.begin(); p != attributes.end(); ++p){
+    std::cout <<  p->second ;
+    }
+  }
+
+/**********************/
+
+void optionsQuery::DumpParser::on_text(Glib::Markup::ParseContext&, const Glib::ustring& text){
+  Glib::ustring trimmed_text = trim_whitespace(text);
+  if (!trimmed_text.empty()) std::cout << " " << trimmed_text << "\n";
+  }
+
+/**********************/ 
+
+// get the contents out of one of our XML settings files
+optionsQuery::optionsQuery(Glib::ustring toParse){
+
+  DumpParser parser;
+  Glib::Markup::ParseContext context (parser);
+
+  try{
+    context.parse(Glib::file_get_contents(toParse));
+    context.end_parse();
+    }
+  catch(const Glib::Error) {
+    std::cout<< "Error! Settings file " << toParse << " not found.\n";
+    }
+  }
+
+/**********************/ 
+
+// write out to file
+optionsQuery::~optionsQuery(){
+  }
+
+/**********************/ 
+
+//set values in out vectors
+  bool optionsQuery::set_option(Glib::ustring, Glib::ustring){}
+
+/**********************/ 
+
+//return set values
+  Glib::ustring optionsQuery::get_option(Glib::ustring){}
+
+/**********************/ 

Added: trunk/src/optionsManager.h
===================================================================
--- trunk/src/optionsManager.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/optionsManager.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -0,0 +1,46 @@
+/* Darimasen - optionsManager.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
+
+#ifndef OPTIONS_H
+#define OPTIONS_H
+
+/**********************/
+
+#include "main.h"
+
+/**********************/
+
+Glib::ustring int2ustr(int);
+Glib::ustring underscoreSafe(Glib::ustring);
+Glib::ustring getchoicesdir();
+void goruncommand(Glib::ustring, Glib::ustring);
+Glib::ustring trim_whitespace(const Glib::ustring&);
+/**********************/
+
+class optionsQuery{
+
+
+  class DumpParser : public Glib::Markup::Parser {
+    void on_start_element(Glib::Markup::ParseContext&, const Glib::ustring&, const AttributeMap&);
+    void on_text(Glib::Markup::ParseContext& context, const Glib::ustring& text);
+    };
+
+  struct optionholder {
+    Glib::ustring name;
+    Glib::ustring value;
+    };
+
+  std::vector<optionholder> optionVector;
+  
+  public:
+
+  optionsQuery(Glib::ustring);
+  ~optionsQuery();
+
+  bool set_option(Glib::ustring, Glib::ustring);
+
+  Glib::ustring get_option(Glib::ustring);
+  };
+
+/**********************/
+
+#endif //SUPPLIMENTAL_H

Modified: trunk/src/supplimental.cpp
===================================================================
--- trunk/src/supplimental.cpp	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/supplimental.cpp	2005-05-14 17:18:39 UTC (rev 72)
@@ -1,7 +1,8 @@
 /* Darimasen - supplimental.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
+
+/**********************/
 
-#include "supplimental.h"
-
+#include "supplimental.h"
 /**********************/
 
 Glib::ustring int2ustr(int x){
@@ -34,21 +35,33 @@
 
 //check which choices dir to use
 Glib::ustring getchoicesdir(){
-  Glib::RefPtr<Gnome::Vfs::Uri> choicespath = Gnome::Vfs::Uri::create(
-    (Glib::ustring)getenv("HOME") + "/Choices");
-  if (choicespath->uri_exists()){
-    return "/Choices";
-    }
-  return "/.choices";
+  if (Gnome::Vfs::Uri::create(Glib::get_home_dir() + "/Choices")->uri_exists()) return "/Choices";
+  else return "/.choices";
   }
 
 /**********************/
 
+//execute a command in the correct working directory
 void goruncommand(Glib::ustring exec, Glib::ustring path){
-//execute a command in the correct working directory
-    Glib::ArrayHandle<std::string> cmd_args = Glib::shell_parse_argv(exec);
-    Glib::spawn_async(path, cmd_args, Glib::SPAWN_SEARCH_PATH);
-
+    Glib::spawn_async(path, Glib::shell_parse_argv(exec), Glib::SPAWN_SEARCH_PATH);
   }
   
+/**********************/
+
+Glib::ustring trim_whitespace(const Glib::ustring& text)
+{
+  Glib::ustring::const_iterator pbegin (text.begin());
+  Glib::ustring::const_iterator pend   (text.end());
+
+  while(pbegin != pend && Glib::Unicode::isspace(*pbegin))
+    ++pbegin;
+
+  Glib::ustring::const_iterator temp (pend);
+
+  while(pbegin != temp && Glib::Unicode::isspace(*--temp))
+    pend = temp;
+
+  return Glib::ustring(pbegin, pend);
+}
+
 /**********************/ 

Modified: trunk/src/supplimental.h
===================================================================
--- trunk/src/supplimental.h	2005-05-09 11:07:36 UTC (rev 71)
+++ trunk/src/supplimental.h	2005-05-14 17:18:39 UTC (rev 72)
@@ -5,8 +5,7 @@
 
 /**********************/
 
-#include "main.h"
-#include <iostream>
+#include "main.h"
 
 /**********************/
 
@@ -14,7 +13,8 @@
 Glib::ustring underscoreSafe(Glib::ustring);
 Glib::ustring getchoicesdir();
 void goruncommand(Glib::ustring, Glib::ustring);
-
+Glib::ustring trim_whitespace(const Glib::ustring&);
+
 /**********************/
 
 #endif //SUPPLIMENTAL_H



From darimasen-svn-admin at lists.berlios.de  Tue May 17 11:20:47 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Tue, 17 May 2005 11:20:47 +0200
Subject: [Darimasen-svn] r74 - trunk/src
Message-ID: <200505170920.j4H9KlDl018467@sheep.berlios.de>

Author: metwo
Date: 2005-05-17 11:20:39 +0200 (Tue, 17 May 2005)
New Revision: 74

Modified:
   trunk/src/damenu.cpp
   trunk/src/firsttime.cpp
   trunk/src/iconmodes.cpp
Log:
Fixed minor typos and layout errors.


Modified: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-05-17 02:46:54 UTC (rev 73)
+++ trunk/src/damenu.cpp	2005-05-17 09:20:39 UTC (rev 74)
@@ -181,7 +181,7 @@
 
 
     prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Opening " + path + " from here consistantly leads to errors"));
+      Gtk::Menu_Helpers::MenuElem("Opening " + path + " from here consistently leads to errors"));
 
     prompt.items().push_back(
       Gtk::Menu_Helpers::MenuElem("Open In new Tab",

Modified: trunk/src/firsttime.cpp
===================================================================
--- trunk/src/firsttime.cpp	2005-05-17 02:46:54 UTC (rev 73)
+++ trunk/src/firsttime.cpp	2005-05-17 09:20:39 UTC (rev 74)
@@ -11,7 +11,8 @@
    okbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
    image1 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-dialog-question"), Gtk::IconSize(6)));
    label1 = Gtk::manage(new class Gtk::Label("It looks like this is your first time\n"
-		"running Darimasen (and have not used ROX).\n\n"
+		"running Darimasen (and you \n"
+		"have not used ROX).\n\n"
 		"This is a good time to set up\n"
 		"some default \"Run Actions\"\n\n"
 		"Simply replace the wildcard (*)\n"

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-17 02:46:54 UTC (rev 73)
+++ trunk/src/iconmodes.cpp	2005-05-17 09:20:39 UTC (rev 74)
@@ -207,7 +207,7 @@
         }
       break;
     default:
-      parent->parent->set_message("Well, that was usefull.");
+      parent->parent->set_message("Well, that was useful.");
       break;
     }
   }
@@ -581,6 +581,9 @@
    group = new class Gtk::Label("Group");
    others = new class Gtk::Label("Everybody");
 
+   user->set_alignment(0.96,0.5);
+   group->set_alignment(0.96,0.5);
+
    explaination = new class Gtk::Label("for \""+ info->get_name() + "\"...");
 
    layout = new class Gtk::Table(5, 6, false);



From darimasen-svn-admin at lists.berlios.de  Thu May 19 02:39:10 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Thu, 19 May 2005 02:39:10 +0200
Subject: [Darimasen-svn] r75 - in trunk: . src
Message-ID: <200505190039.j4J0dAeg021715@sheep.berlios.de>

Author: sudrien
Date: 2005-05-19 02:38:46 +0200 (Thu, 19 May 2005)
New Revision: 75

Modified:
   trunk/README
   trunk/TODO
   trunk/darimasen-0.0.8.ebuild
   trunk/distribute.sh
   trunk/src/damenu.cpp
   trunk/src/damenu.h
   trunk/src/darimasen.cpp
   trunk/src/iconmodes.cpp
   trunk/src/iconmodes.h
   trunk/src/optionsManager.cpp
Log:
ready for 0.0.8 release

Modified: trunk/README
===================================================================
--- trunk/README	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/README	2005-05-19 00:38:46 UTC (rev 75)
@@ -1,15 +1,13 @@
-Darimasen File Manager - 0.0.7 [Feature Incomplete - Only for Experimental Use]
+Darimasen File Manager - 0.0.8 [Feature Incomplete - Only for Experimental Use]
 
 Readme.txt - 8 Apr. 2005
 
 --
 
-0.0.7 hs been released because:
+0.0.8 hs been released because:
 
-1. Now with tabs, it is at least as stable as 0.0.6
-2. Except for DnD, THe navigation system is believed to be complete.
+The code has reached a peak in functionality. 
 
-It has better stability and such. Pretty sure. It's faster at several points.
 
 --
 
@@ -44,6 +42,7 @@
 --
 
 
+
 http://darimasen.berlios.de
 
 

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/TODO	2005-05-19 00:38:46 UTC (rev 75)
@@ -1,46 +1,69 @@
-version 0.0.8
+Starting over
 
-Must do:
+by Sudrien
 
-Move, copy, delete of files needs more checking (or at least feedback)
-move, copy, delete of folder
-move, copy of folder contents
-detail view
 
 
-Would like to do:
+Darimasen is my first real project, my first useful project beyond 
+all the examples and tests of my formal education. I deliberately
+choose somthing with high complexity: there are not that many file
+managers compared with other genres of programming, and the menu system
+of navigation is possible the first of its kind.
 
-Keyboard navigation of menus (Alt+1 opens root menu, Alt+2 opens first child, etc)
-set unreadable folders insensitive, etc.
-Create new folder
+And that is where all the difficulties come in.
 
+One can design for a standard navigation FM, because it is standard. There
+are expected actions, responces, etc. Tabs are not too much of an extension;
+keep multiple instances available of everything, make simple consistancy checks
+when major operations happen (copy, delete, and so on).
 
-nicities:
-When deleting a file (or any other operation that leaves you in the same dir
- in the current window), keep the scrolled position in the same place if possible.
-limiting DaMenu expansion (preserve window width for long paths) - by shortening menu names
-use existing thumbnails / create new thumbnails (a la ROX)
+But the Darimasen Menu system can allow you to do ANY operation on ANY
+file in ANY location. The checks required to do this properly and consistantly...
 
-version 0.0.9
------------------------------------------------
+...requires everything to be self-aware.
 
-Optional Directory tree, updated as needed
 
-Package as appdir?
+0.0.8 is proof that the Darimasen Menu System can work. Efficiently, even.
 
------------------------------------------------
+Now comes the checking.
 
---version 0.1.0 (beta?)
+If a tab is no longer needed, it goes.
+If a file is gone, its icon drops from the face of the earth.
 
-anouncement of usuable public release ^_^;
 
 
------------------------------------------------
 
---version 0.1.1 and onwards
+Very little doesn't need to be redesigned and rewritten. I might even switch to C#.
 
-Drag and drop - into menu, between tabs, copy/paste/link popup, multiple selection
-Re-port to windows?
-Consider DnD holding box - a "Drop stack". 
 
 
+
+Up to this point, I was making a system.
+After this, I'm making a File manager.
+
+
+-Sudrien.
+
+
+
+----------
+
+
+With that said, Here is the known future of the Darimasen project.
+
+The current SVN repository will become "Darimasen-0.0.x"; there will be no branch,
+due to the fact that everything will be starting again.
+
+The release of 0.0.9 is possible; it will be a buxfix release, with no added features
+currently expected. 0.0.10 will follow, if need be.
+
+There will be no version 0.1.0 - that would send the wrong signal, as far as I'm
+ concerned. 0.1.x will come next - it will contain rich descriptions of each of
+the planned components, a plain text file accompanying every source file. Every 25 commits
+there will be a release, format 0.1.date. Care will be taken that it can be compilable,
+using either g++ or mono ( want garbage collection - I really do ). It will continue to use
+Gtk+-2.6-wrapped widgets. As I haven't downloaded mono yet, it will probably be a while. 
+
+
+
+

Modified: trunk/darimasen-0.0.8.ebuild
===================================================================
--- trunk/darimasen-0.0.8.ebuild	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/darimasen-0.0.8.ebuild	2005-05-19 00:38:46 UTC (rev 75)
@@ -23,7 +23,9 @@
 
 src_compile() {
 
+	elibtoolize
 	econf || die
+	elibtoolize
 	emake || die
 }
 

Modified: trunk/distribute.sh
===================================================================
--- trunk/distribute.sh	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/distribute.sh	2005-05-19 00:38:46 UTC (rev 75)
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 cd ..
-mkdir darimasen-0.0.7
-cp -R trunk/* darimasen-0.0.7/
-cd darimasen-0.0.7/
+mkdir darimasen-0.0.8
+cp -R trunk/* darimasen-0.0.8/
+cd darimasen-0.0.8/
 
 rm -Rf .svn/
 rm -Rf src/.svn/
@@ -26,4 +26,4 @@
 
 cd ..
 
-tar -cjvf darimasen-0.0.7.tar.bz2 darimasen-0.0.7/
+tar -cjvf darimasen-0.0.8.tar.bz2 darimasen-0.0.8/

Modified: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/damenu.cpp	2005-05-19 00:38:46 UTC (rev 75)
@@ -180,8 +180,8 @@
       prompt.items().pop_back();
 
 
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Opening " + path + " from here consistently leads to errors"));
+    //prompt.items().push_back(
+    //  Gtk::Menu_Helpers::MenuElem("Opening " + path + " from here consistently leads to errors"));
 
     prompt.items().push_back(
       Gtk::Menu_Helpers::MenuElem("Open In new Tab",
@@ -208,9 +208,10 @@
 
     prompt.items().push_back(
       Gtk::Menu_Helpers::MenuElem("Delete...",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*this,&DarimasenMenu::unlinkify),path)));
+        sigc::bind<Glib::ustring,gint>(
+          sigc::mem_fun(*this,&DarimasenMenu::unlinkify),path,pos)));
 
+    /*
     prompt.items().push_back(
       Gtk::Menu_Helpers::SeparatorElem());
 
@@ -218,10 +219,10 @@
       Gtk::Menu_Helpers::MenuElem("Add to location menu",
         sigc::bind<Glib::ustring>(
           sigc::mem_fun(*this,&DarimasenMenu::bookmark),path)));
+    */
+    prompt.signal_selection_done().connect_notify(
+      sigc::mem_fun(*MenuItemArray[pos],&Gtk::MenuItem::deselect));
 
-  //  prompt.signal_selection_done().connect_notify(sigc::mem_fun(prompt,&Gtk::Menu::hide));
-  //  prompt.signal_selection_done().connect_notify(sigc::mem_fun(*MenuArray[pos],&Gtk::Menu::hide));
-    prompt.signal_selection_done().connect_notify(sigc::mem_fun(*MenuItemArray[pos],&Gtk::MenuItem::deselect));
 	
     prompt.popup(event->button, event->time);
   return true;
@@ -232,7 +233,11 @@
   //DaFileLister(); //5:45pm, 24 Dec 2004, it worked! // leave this comment    
   }
 
+/**********************/
 
+void DarimasenMenu::bookmark(Glib::ustring path){
+  }
+
 /**********************/
 
 void DarimasenMenu::copy(Glib::ustring path){
@@ -243,11 +248,11 @@
    
   Gtk::RadioButton::Group _RadioBGroup_radiobutton4;
   Gtk::RadioButton * radiobutton4 = Gtk::manage(
-    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy Directory to ... (cp .)"));
+    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy Directory to ... (cp -R)"));
   Gtk::RadioButton * radiobutton5 = Gtk::manage(
     new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy files in directory to ... (cp *)"));
   Gtk::RadioButton * radiobutton6 = Gtk::manage(
-    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy everything in directory to ... (cp -R *)"));
+    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy everything in directory to ... (cp -R \*)"));
   Gtk::Entry * entry2 = Gtk::manage(new class Gtk::Entry());
   cancelbutton2->set_flags(Gtk::CAN_FOCUS);
   cancelbutton2->set_flags(Gtk::CAN_DEFAULT);
@@ -274,11 +279,22 @@
 
   switch(copyDialogue.run()){
     case(Gtk::RESPONSE_OK):{
-      std::cout << path << "moved\n";
+      parent->set_message( path + "moved");
+  if(radiobutton4->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"cp -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"");
+}
+  if(radiobutton5->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"cp \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"*");
+}
+  if(radiobutton6->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"cp -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"*");
+
+
+}
       return;
       }
     default:{
-      std::cout << path << "not moved\n";
+      std::cout << path << "not copied\n";
       return;
       }
     }
@@ -294,11 +310,11 @@
    
   Gtk::RadioButton::Group _RadioBGroup_radiobutton1;
   Gtk::RadioButton * radiobutton1 = Gtk::manage(new class Gtk::RadioButton(
-    _RadioBGroup_radiobutton1, "Move " + path + " to ... (mv .)"));
+    _RadioBGroup_radiobutton1, "Move " + path + " to ... (mv -R )"));
   Gtk::RadioButton * radiobutton2 = Gtk::manage(new class Gtk::RadioButton(
     _RadioBGroup_radiobutton1, "Move files in directory to... (mv *)"));
   Gtk::RadioButton * radiobutton3 = Gtk::manage(new class Gtk::RadioButton(
-    _RadioBGroup_radiobutton1, "Move everything in directory to... (mv -R *)"));
+    _RadioBGroup_radiobutton1, "Move everything in directory to... (mv -R \*)"));
   Gtk::Entry * entry1 = Gtk::manage(new class Gtk::Entry());
   cancelbutton1->set_flags(Gtk::CAN_FOCUS);
   cancelbutton1->set_flags(Gtk::CAN_DEFAULT);
@@ -324,7 +340,20 @@
 
   switch(moveDialogue.run()){
     case(Gtk::RESPONSE_OK):{
-      std::cout << path << "moved\n";
+      parent->set_message( path + "moved");
+  if(radiobutton1->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"mv -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"");
+}
+  if(radiobutton2->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"mv \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"*");
+}
+  if(radiobutton3->get_active()){
+  Glib::spawn_command_line_async((Glib::ustring)"mv -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"*");
+
+
+}
+      // rebuild this menu if needed
+      //check if any other menus effected, if so, set for rebuild
       return;
       }
     default:{
@@ -371,7 +400,13 @@
 
   switch(linkDialogue.run()){
     case(Gtk::RESPONSE_OK):{
-      std::cout << "link created " + path << "\n";
+
+
+  Glib::spawn_command_line_async((Glib::ustring)"ln -s \""  + label1->get_text().c_str() + (Glib::ustring)"\" \"" + entry3->get_text().c_str() + "\"");
+
+      parent->set_message( "link created " + path );
+
+      //check and see if link path is in any menus, set for rebuild if true.
       return;
       }
     default:{
@@ -384,7 +419,7 @@
 /**********************/
 
 
-void DarimasenMenu::unlinkify(Glib::ustring path){
+void DarimasenMenu::unlinkify(Glib::ustring path, gint menu){
   Gtk::Dialog unlinkifyDialogue;
   Gtk::Button * cancelbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
   Gtk::Button * okbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
@@ -410,18 +445,20 @@
 
   switch(unlinkifyDialogue.run()){
     case(Gtk::RESPONSE_OK):{
-      std::cout << "Deleted " + path << "\n";
+
+      Glib::spawn_command_line_async((Glib::ustring)"rm -Rf \""  + path + "\"");
+      needsRebuild[menu] = true;
+      //check if any of the windows contain that path, do what? 
+      parent->set_message("Deleted " + path); 
       return;
       }
     default:{
-      std::cout << "No deletion " + path << "\n";
+      parent->set_message("nothing deleted");
       return;
       }
     }
   }
 
-    void DarimasenMenu::bookmark(Glib::ustring path){}
-
 /**********************/
 
 // provides the numbers by the arrows. 

Modified: trunk/src/damenu.h
===================================================================
--- trunk/src/damenu.h	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/damenu.h	2005-05-19 00:38:46 UTC (rev 75)
@@ -37,7 +37,7 @@
   bool * needsRebuild;
   bool SpecialMenuForPath(GdkEventButton* , int, Glib::ustring  , Glib::ustring);
   void selection_reset(guint, Glib::ustring);
-  void unlinkify(Glib::ustring);
+  void unlinkify(Glib::ustring,gint);
 
 public:
 

Modified: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/darimasen.cpp	2005-05-19 00:38:46 UTC (rev 75)
@@ -279,7 +279,7 @@
 /**********************/
 
 void Darimasen::fChangeIconMode(){
-  mode = (mode + 1) % 2; // increment, mod of possibilities.
+  mode = (mode + 1) % 3; // increment, mod of possibilities.
   for(int i = 0; i < history.size(); i++){
       ChangeCurrentPath(get_history(i),false,false);
     } 
@@ -558,6 +558,14 @@
 
   for(int i = 0; i < history.size(); i++){
     if( get_history(i) == sourceDir || get_history(i) == targetDir ){
+
+/*
+if (!Gnome::Vfs::Uri::create(get_history(i))->uri_exists()){
+  Glib::ustring temp = get_history(i);
+  del_history(i);
+  set_history(i, temp.substr(0, temp.rfind(slash)) + slash);
+}*/
+
       ChangeCurrentPath(get_history(i),false,false);
       }
     }

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/iconmodes.cpp	2005-05-19 00:38:46 UTC (rev 75)
@@ -871,6 +871,16 @@
 
 void DaIconModes::MoveDialogue::onOk(){
   Glib::spawn_command_line_async((Glib::ustring)"mv \""  + label->get_text().c_str() + (Glib::ustring)"\" \"" + entry->get_text().c_str()+ "\"");
+/*
+  try
+  {
+    Gnome::Vfs::Transfer::transfer(label->get_text().c_str(), entry->get_text().c_str());  
+  }
+  catch(const Gnome::Vfs::exception& ex)
+  {
+    // if the operation was not successful, print the error
+    std::cout << "Error occurred: " << label->get_text() << ", " << ex.what() << std::endl;
+  }*/
 
   grandparent->updateView(
     label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
@@ -923,10 +933,19 @@
 void DaIconModes::DeleteDialogue::onOk(){
   Glib::spawn_command_line_async((Glib::ustring)"rm \""  + label->get_text().c_str() + "\"");
 
+/*  try
+  {
+    Gnome::Vfs::Transfer::remove(label->get_text().c_str());  
+  }
+  catch(const Gnome::Vfs::exception& ex)
+  {
+    // if the operation was not successful, print the error
+    std::cout << "Error occurred: " << label->get_text() << ", " << ex.what() << std::endl;
+  }*/
+
   grandparent->updateView(
     label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
     label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1));
-   //std::cout << label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1) ;
   hide();
   }
 
@@ -953,6 +972,15 @@
   return true;
   }
 
+/**********************
+
+bool on_transfer_progress(const Gnome::Vfs::Transfer::ProgressInfo& info){
+//if (info->get_vfs_status() == Gnome::Vfs::OK)
+//  parent->set_message("OK!");
+
+
+    }
+
 /**********************/
 
 void DaIconModes::on_size_allocate(Gtk::Allocation& allocation){

Modified: trunk/src/iconmodes.h
===================================================================
--- trunk/src/iconmodes.h	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/iconmodes.h	2005-05-19 00:38:46 UTC (rev 75)
@@ -227,6 +227,7 @@
 
   bool addEntry(Glib::ustring, Glib::RefPtr<const Gnome::Vfs::FileInfo>, bool, bool);
   void on_size_allocate(Gtk::Allocation&);
+ // bool on_transfer_progress(const Gnome::Vfs::Transfer::ProgressInfo&);
   void redraw();
 
   class Darimasen * parent;

Modified: trunk/src/optionsManager.cpp
===================================================================
--- trunk/src/optionsManager.cpp	2005-05-17 09:20:39 UTC (rev 74)
+++ trunk/src/optionsManager.cpp	2005-05-19 00:38:46 UTC (rev 75)
@@ -17,7 +17,7 @@
     context.end_parse();
     }
   catch(const Glib::Error) {
-    std::cout<< "Error! Settings file " << toParse << " not found.\n";
+    //std::cout<< "Error! Settings file " << toParse << " not found.\n";
     }
   }
 



From darimasen-svn-admin at lists.berlios.de  Mon May 23 02:35:51 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Mon, 23 May 2005 02:35:51 +0200
Subject: [Darimasen-svn] r76 - /
Message-ID: <200505230035.j4N0Zpko030481@sheep.berlios.de>

Author: sudrien
Date: 2005-05-23 02:35:14 +0200 (Mon, 23 May 2005)
New Revision: 76

Added:
   0.0.x/
Log:
splitting 0.0.x off for bugs-only work

Copied: 0.0.x (from rev 75, trunk)



From darimasen-svn-admin at lists.berlios.de  Mon May 23 05:07:41 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Mon, 23 May 2005 05:07:41 +0200
Subject: [Darimasen-svn] r77 - 0.0.x trunk trunk/src
Message-ID: <200505230307.j4N37fqj026659@sheep.berlios.de>

Author: sudrien
Date: 2005-05-23 05:07:19 +0200 (Mon, 23 May 2005)
New Revision: 77

Added:
   0.0.x/darimasen-svn-0.1-r1.ebuild
   trunk/darimasen-svn-0.2.ebuild
Removed:
   0.0.x/darimasen-svn-0.1.ebuild
   trunk/darimasen-svn-0.1.ebuild
   trunk/src/damenu.cpp
   trunk/src/damenu.h
   trunk/src/darimasen.cpp
   trunk/src/darimasen.h
   trunk/src/firsttime.cpp
   trunk/src/firsttime.h
   trunk/src/iconmodes.cpp
   trunk/src/iconmodes.h
   trunk/src/main.cpp
   trunk/src/main.h
   trunk/src/optionsManager.cpp
   trunk/src/optionsManager.h
   trunk/src/supplimental.cpp
   trunk/src/supplimental.h
Modified:
   trunk/src/Makefile.am
Log:
ebuild updates and cleaning out

Copied: 0.0.x/darimasen-svn-0.1-r1.ebuild (from rev 76, 0.0.x/darimasen-svn-0.1.ebuild)
===================================================================
--- 0.0.x/darimasen-svn-0.1.ebuild	2005-05-23 00:35:14 UTC (rev 76)
+++ 0.0.x/darimasen-svn-0.1-r1.ebuild	2005-05-23 03:07:19 UTC (rev 77)
@@ -0,0 +1,114 @@
+# Copyright 1999-2004 Gentoo Technologies, Inc.
+# Distributed under the terms of the GNU General Public License v2
+# $Header: $
+
+
+ESVN_REPO_URI="svn://svn.berlios.de/darimasen/0.0.x"
+ESVN_PROJECT="darimasen"
+ESVN_BOOTSTRAP="autogen.sh"
+inherit subversion
+
+DESCRIPTION="A file manager with menu-based navigation"
+HOMEPAGE="http://darimasen.berlios.de/"
+
+LICENSE="GPL-2"
+SLOT="0"
+KEYWORDS="~x86"
+
+IUSE=""
+SLOT="0"
+
+DEPEND=">=dev-libs/libsigc++-2.0.3
+        >=dev-cpp/gtkmm-2.6.1
+        >=dev-cpp/gnome-vfsmm-2.6.0
+        x11-themes/gnome-icon-theme"
+RDEPEND="!x11-misc/darimasen"
+
+
+subversion_svn_fetch() {
+
+	# ESVN_REPO_URI is empty.
+	[ -z "${ESVN_REPO_URI}" ] && die "subversion.eclass: ESVN_REPO_URI is empty."
+
+	# http and https only...
+	case ${ESVN_REPO_URI%%:*} in
+		http)	;;
+		https)	;;
+		svn)	;;
+		*)
+			die "subversion.eclass: fetch from "${ESVN_REPO_URI%:*}" is not yet implemented."
+			;;
+	esac
+
+	# every time
+	addwrite "${ESVN_STORE_DIR}"
+	addwrite "/etc/subversion"
+
+	# -userpriv
+	addwrite "/root/.subversion"
+
+	if [ ! -d "${ESVN_STORE_DIR}" ]; then
+		mkdir -p "${ESVN_STORE_DIR}" || die "subversion.eclass: can't mkdir ${ESVN_STORE_DIR}."
+		chmod -f o+rw "${ESVN_STORE_DIR}" || die "subversion.eclass: can't chmod ${ESVN_STORE_DIR}."
+		einfo "created store directory: ${ESVN_STORE_DIR}"
+		einfo
+	fi
+
+	cd "${ESVN_STORE_DIR}"
+
+	if [ -z ${ESVN_REPO_URI##*/} ]; then
+		ESVN_REPO_FIX="${ESVN_REPO_URI%/}"
+	else
+		ESVN_REPO_FIX="${ESVN_REPO_URI}"
+	fi
+
+	ESVN_CO_DIR="${ESVN_PROJECT}/${ESVN_REPO_FIX##*/}"
+
+	if [ ! -d "${ESVN_CO_DIR}/.svn" ]; then
+		# first check out
+		einfo "subversion check out start -->"
+		einfo
+		einfo "check out from: ${ESVN_REPO_URI}"
+
+		mkdir -p "${ESVN_PROJECT}" || die "subversion.eclass: can't mkdir ${ESVN_PROJECT}."
+		chmod -f o+rw "${ESVN_PROJECT}" || die "subversion.eclass: can't chmod ${ESVN_PROJECT}."
+		cd "${ESVN_PROJECT}"
+		${ESVN_FETCH_CMD} "${ESVN_REPO_URI}" || die "subversion.eclass: can't fetch from ${ESVN_REPO_URI}."
+		einfo "     stored in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
+
+	else
+		# update working copy
+		einfo "subversion update start -->"
+		einfo
+		einfo "   update from: ${ESVN_REPO_URI}"
+
+		cd "${ESVN_CO_DIR}"
+		${ESVN_UPDATE_CMD} || die "subversion.eclass: can't update from ${ESVN_REPO_URI}."
+		einfo "    updated in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
+	fi
+
+	# permission fix
+	chmod -Rf o+rw . 2>/dev/null
+
+	# copy to the ${WORKDIR}
+	cp -Rf "${ESVN_STORE_DIR}/${ESVN_CO_DIR}" "${WORKDIR}/${P}" || die "subversion.eclass: can't copy to ${WORKDIR}/${P}."
+	einfo
+
+}
+
+src_compile() {
+	export WANT_AUTOCONF=2.5
+
+	econf || die
+	emake || die
+}
+
+
+
+
+src_install() {
+	einfo "Installing..."
+	make DESTDIR=${D} install || die "make install failed"
+	dodoc README* AUTHORS TODO* COPYING
+}
+

Deleted: 0.0.x/darimasen-svn-0.1.ebuild
===================================================================
--- 0.0.x/darimasen-svn-0.1.ebuild	2005-05-23 00:35:14 UTC (rev 76)
+++ 0.0.x/darimasen-svn-0.1.ebuild	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,114 +0,0 @@
-# Copyright 1999-2004 Gentoo Technologies, Inc.
-# Distributed under the terms of the GNU General Public License v2
-# $Header: $
-
-
-ESVN_REPO_URI="svn://svn.berlios.de/darimasen/trunk"
-ESVN_PROJECT="darimasen"
-ESVN_BOOTSTRAP="autogen.sh"
-inherit subversion
-
-DESCRIPTION="A file manager with menu-based navigation"
-HOMEPAGE="http://darimasen.berlios.de/"
-
-LICENSE="GPL-2"
-SLOT="0"
-KEYWORDS="~x86"
-
-IUSE=""
-SLOT="0"
-
-DEPEND=">=dev-libs/libsigc++-2.0.3
-        >=dev-cpp/gtkmm-2.6.1
-        >=dev-cpp/gnome-vfsmm-2.6.0
-        x11-themes/gnome-icon-theme"
-RDEPEND="!x11-misc/darimasen"
-
-
-subversion_svn_fetch() {
-
-	# ESVN_REPO_URI is empty.
-	[ -z "${ESVN_REPO_URI}" ] && die "subversion.eclass: ESVN_REPO_URI is empty."
-
-	# http and https only...
-	case ${ESVN_REPO_URI%%:*} in
-		http)	;;
-		https)	;;
-		svn)	;;
-		*)
-			die "subversion.eclass: fetch from "${ESVN_REPO_URI%:*}" is not yet implemented."
-			;;
-	esac
-
-	# every time
-	addwrite "${ESVN_STORE_DIR}"
-	addwrite "/etc/subversion"
-
-	# -userpriv
-	addwrite "/root/.subversion"
-
-	if [ ! -d "${ESVN_STORE_DIR}" ]; then
-		mkdir -p "${ESVN_STORE_DIR}" || die "subversion.eclass: can't mkdir ${ESVN_STORE_DIR}."
-		chmod -f o+rw "${ESVN_STORE_DIR}" || die "subversion.eclass: can't chmod ${ESVN_STORE_DIR}."
-		einfo "created store directory: ${ESVN_STORE_DIR}"
-		einfo
-	fi
-
-	cd "${ESVN_STORE_DIR}"
-
-	if [ -z ${ESVN_REPO_URI##*/} ]; then
-		ESVN_REPO_FIX="${ESVN_REPO_URI%/}"
-	else
-		ESVN_REPO_FIX="${ESVN_REPO_URI}"
-	fi
-
-	ESVN_CO_DIR="${ESVN_PROJECT}/${ESVN_REPO_FIX##*/}"
-
-	if [ ! -d "${ESVN_CO_DIR}/.svn" ]; then
-		# first check out
-		einfo "subversion check out start -->"
-		einfo
-		einfo "check out from: ${ESVN_REPO_URI}"
-
-		mkdir -p "${ESVN_PROJECT}" || die "subversion.eclass: can't mkdir ${ESVN_PROJECT}."
-		chmod -f o+rw "${ESVN_PROJECT}" || die "subversion.eclass: can't chmod ${ESVN_PROJECT}."
-		cd "${ESVN_PROJECT}"
-		${ESVN_FETCH_CMD} "${ESVN_REPO_URI}" || die "subversion.eclass: can't fetch from ${ESVN_REPO_URI}."
-		einfo "     stored in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
-
-	else
-		# update working copy
-		einfo "subversion update start -->"
-		einfo
-		einfo "   update from: ${ESVN_REPO_URI}"
-
-		cd "${ESVN_CO_DIR}"
-		${ESVN_UPDATE_CMD} || die "subversion.eclass: can't update from ${ESVN_REPO_URI}."
-		einfo "    updated in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
-	fi
-
-	# permission fix
-	chmod -Rf o+rw . 2>/dev/null
-
-	# copy to the ${WORKDIR}
-	cp -Rf "${ESVN_STORE_DIR}/${ESVN_CO_DIR}" "${WORKDIR}/${P}" || die "subversion.eclass: can't copy to ${WORKDIR}/${P}."
-	einfo
-
-}
-
-src_compile() {
-	export WANT_AUTOCONF=2.5
-
-	econf || die
-	emake || die
-}
-
-
-
-
-src_install() {
-	einfo "Installing..."
-	make DESTDIR=${D} install || die "make install failed"
-	dodoc README* AUTHORS TODO* COPYING
-}
-

Deleted: trunk/darimasen-svn-0.1.ebuild
===================================================================
--- trunk/darimasen-svn-0.1.ebuild	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/darimasen-svn-0.1.ebuild	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,114 +0,0 @@
-# Copyright 1999-2004 Gentoo Technologies, Inc.
-# Distributed under the terms of the GNU General Public License v2
-# $Header: $
-
-
-ESVN_REPO_URI="svn://svn.berlios.de/darimasen/trunk"
-ESVN_PROJECT="darimasen"
-ESVN_BOOTSTRAP="autogen.sh"
-inherit subversion
-
-DESCRIPTION="A file manager with menu-based navigation"
-HOMEPAGE="http://darimasen.berlios.de/"
-
-LICENSE="GPL-2"
-SLOT="0"
-KEYWORDS="~x86"
-
-IUSE=""
-SLOT="0"
-
-DEPEND=">=dev-libs/libsigc++-2.0.3
-        >=dev-cpp/gtkmm-2.6.1
-        >=dev-cpp/gnome-vfsmm-2.6.0
-        x11-themes/gnome-icon-theme"
-RDEPEND="!x11-misc/darimasen"
-
-
-subversion_svn_fetch() {
-
-	# ESVN_REPO_URI is empty.
-	[ -z "${ESVN_REPO_URI}" ] && die "subversion.eclass: ESVN_REPO_URI is empty."
-
-	# http and https only...
-	case ${ESVN_REPO_URI%%:*} in
-		http)	;;
-		https)	;;
-		svn)	;;
-		*)
-			die "subversion.eclass: fetch from "${ESVN_REPO_URI%:*}" is not yet implemented."
-			;;
-	esac
-
-	# every time
-	addwrite "${ESVN_STORE_DIR}"
-	addwrite "/etc/subversion"
-
-	# -userpriv
-	addwrite "/root/.subversion"
-
-	if [ ! -d "${ESVN_STORE_DIR}" ]; then
-		mkdir -p "${ESVN_STORE_DIR}" || die "subversion.eclass: can't mkdir ${ESVN_STORE_DIR}."
-		chmod -f o+rw "${ESVN_STORE_DIR}" || die "subversion.eclass: can't chmod ${ESVN_STORE_DIR}."
-		einfo "created store directory: ${ESVN_STORE_DIR}"
-		einfo
-	fi
-
-	cd "${ESVN_STORE_DIR}"
-
-	if [ -z ${ESVN_REPO_URI##*/} ]; then
-		ESVN_REPO_FIX="${ESVN_REPO_URI%/}"
-	else
-		ESVN_REPO_FIX="${ESVN_REPO_URI}"
-	fi
-
-	ESVN_CO_DIR="${ESVN_PROJECT}/${ESVN_REPO_FIX##*/}"
-
-	if [ ! -d "${ESVN_CO_DIR}/.svn" ]; then
-		# first check out
-		einfo "subversion check out start -->"
-		einfo
-		einfo "check out from: ${ESVN_REPO_URI}"
-
-		mkdir -p "${ESVN_PROJECT}" || die "subversion.eclass: can't mkdir ${ESVN_PROJECT}."
-		chmod -f o+rw "${ESVN_PROJECT}" || die "subversion.eclass: can't chmod ${ESVN_PROJECT}."
-		cd "${ESVN_PROJECT}"
-		${ESVN_FETCH_CMD} "${ESVN_REPO_URI}" || die "subversion.eclass: can't fetch from ${ESVN_REPO_URI}."
-		einfo "     stored in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
-
-	else
-		# update working copy
-		einfo "subversion update start -->"
-		einfo
-		einfo "   update from: ${ESVN_REPO_URI}"
-
-		cd "${ESVN_CO_DIR}"
-		${ESVN_UPDATE_CMD} || die "subversion.eclass: can't update from ${ESVN_REPO_URI}."
-		einfo "    updated in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
-	fi
-
-	# permission fix
-	chmod -Rf o+rw . 2>/dev/null
-
-	# copy to the ${WORKDIR}
-	cp -Rf "${ESVN_STORE_DIR}/${ESVN_CO_DIR}" "${WORKDIR}/${P}" || die "subversion.eclass: can't copy to ${WORKDIR}/${P}."
-	einfo
-
-}
-
-src_compile() {
-	export WANT_AUTOCONF=2.5
-
-	econf || die
-	emake || die
-}
-
-
-
-
-src_install() {
-	einfo "Installing..."
-	make DESTDIR=${D} install || die "make install failed"
-	dodoc README* AUTHORS TODO* COPYING
-}
-

Copied: trunk/darimasen-svn-0.2.ebuild (from rev 76, trunk/darimasen-svn-0.1.ebuild)
===================================================================
--- trunk/darimasen-svn-0.1.ebuild	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/darimasen-svn-0.2.ebuild	2005-05-23 03:07:19 UTC (rev 77)
@@ -0,0 +1,112 @@
+# Copyright 1999-2004 Gentoo Technologies, Inc.
+# Distributed under the terms of the GNU General Public License v2
+# $Header: $
+
+
+ESVN_REPO_URI="svn://svn.berlios.de/darimasen/trunk"
+ESVN_PROJECT="darimasen"
+ESVN_BOOTSTRAP="autogen.sh"
+inherit subversion
+
+DESCRIPTION="A file manager with menu-based navigation"
+HOMEPAGE="http://darimasen.berlios.de/"
+
+LICENSE="GPL-2"
+SLOT="0"
+KEYWORDS="~x86"
+
+IUSE=""
+SLOT="0"
+
+DEPEND=">=dev-dotnet/gnomevfs-sharp
+        x11-themes/gnome-icon-theme"
+RDEPEND="!x11-misc/darimasen"
+
+
+subversion_svn_fetch() {
+
+	# ESVN_REPO_URI is empty.
+	[ -z "${ESVN_REPO_URI}" ] && die "subversion.eclass: ESVN_REPO_URI is empty."
+
+	# http and https only...
+	case ${ESVN_REPO_URI%%:*} in
+		http)	;;
+		https)	;;
+		svn)	;;
+		*)
+			die "subversion.eclass: fetch from "${ESVN_REPO_URI%:*}" is not yet implemented."
+			;;
+	esac
+
+	# every time
+	addwrite "${ESVN_STORE_DIR}"
+	addwrite "/etc/subversion"
+
+	# -userpriv
+	addwrite "/root/.subversion"
+
+	if [ ! -d "${ESVN_STORE_DIR}" ]; then
+		mkdir -p "${ESVN_STORE_DIR}" || die "subversion.eclass: can't mkdir ${ESVN_STORE_DIR}."
+		chmod -f o+rw "${ESVN_STORE_DIR}" || die "subversion.eclass: can't chmod ${ESVN_STORE_DIR}."
+		einfo "created store directory: ${ESVN_STORE_DIR}"
+		einfo
+	fi
+
+	cd "${ESVN_STORE_DIR}"
+
+	if [ -z ${ESVN_REPO_URI##*/} ]; then
+		ESVN_REPO_FIX="${ESVN_REPO_URI%/}"
+	else
+		ESVN_REPO_FIX="${ESVN_REPO_URI}"
+	fi
+
+	ESVN_CO_DIR="${ESVN_PROJECT}/${ESVN_REPO_FIX##*/}"
+
+	if [ ! -d "${ESVN_CO_DIR}/.svn" ]; then
+		# first check out
+		einfo "subversion check out start -->"
+		einfo
+		einfo "check out from: ${ESVN_REPO_URI}"
+
+		mkdir -p "${ESVN_PROJECT}" || die "subversion.eclass: can't mkdir ${ESVN_PROJECT}."
+		chmod -f o+rw "${ESVN_PROJECT}" || die "subversion.eclass: can't chmod ${ESVN_PROJECT}."
+		cd "${ESVN_PROJECT}"
+		${ESVN_FETCH_CMD} "${ESVN_REPO_URI}" || die "subversion.eclass: can't fetch from ${ESVN_REPO_URI}."
+		einfo "     stored in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
+
+	else
+		# update working copy
+		einfo "subversion update start -->"
+		einfo
+		einfo "   update from: ${ESVN_REPO_URI}"
+
+		cd "${ESVN_CO_DIR}"
+		${ESVN_UPDATE_CMD} || die "subversion.eclass: can't update from ${ESVN_REPO_URI}."
+		einfo "    updated in: ${ESVN_STORE_DIR}/${ESVN_CO_DIR}"
+	fi
+
+	# permission fix
+	chmod -Rf o+rw . 2>/dev/null
+
+	# copy to the ${WORKDIR}
+	cp -Rf "${ESVN_STORE_DIR}/${ESVN_CO_DIR}" "${WORKDIR}/${P}" || die "subversion.eclass: can't copy to ${WORKDIR}/${P}."
+	einfo
+
+}
+
+src_compile() {
+	export WANT_AUTOCONF=2.5
+
+	econf || die
+	emake || die
+}
+
+
+
+
+src_install() {
+	einfo "Installing..."
+	make DESTDIR=${D} install || die "make install failed"
+	dodoc README* AUTHORS TODO* COPYING
+}
+

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/Makefile.am	2005-05-23 03:07:19 UTC (rev 77)
@@ -2,21 +2,9 @@
 bin_PROGRAMS = darimasen
 
 darimasen_SOURCES = \
-	darimasen.cpp \
-	iconmodes.cpp \
-	supplimental.cpp \
-        firsttime.cpp \
-	main.cpp \
-	damenu.cpp \
-        optionsManager.cpp
+
 noinst_HEADERS = \
-	darimasen.h \
-	iconmodes.h \
-	supplimental.h \
-        firsttime.h \
-	main.h \
-	damenu.h \
-        optionsManager.h
+
 AM_CXXFLAGS = -I../.. @PKG_CFLAGS@
 
 darimasen_LDADD = -lpthread @LIBS@ @PKG_LIBS@ 

Deleted: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/damenu.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,619 +0,0 @@
-/* Darimasen - damenu.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "damenu.h"
-
-/**********************/
-
-
-// what actually builds the menus for each directory.
-void DarimasenMenu::MenuForPath(
-       int position,
-       Glib::ustring path,
-       Glib::ustring ext){
-
-  int entry = 0;
-
-MenuItemArray[position]->signal_activate().connect_notify(sigc::bind<guint,Glib::ustring>(sigc::mem_fun(*this,&DarimasenMenu:: selection_reset),position,path));
-
-  if( position < depth || ext != ""){
-
-    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem(menulevel[position] + " "));
-    MenuArray[position]->attach(*subdir, 0 ,4, entry++, entry+1);
-    subdir->show();
-
-          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
-
-    if ( ext != "" ){
-          subdir->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,true));
-      }
-    else {
-          subdir->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,false));
-      }
-
-    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
-    MenuArray[position]->attach(*sep, 0 ,4, entry++, entry+1);
-    sep->show();
-    }
-
-  try{
-    Gnome::Vfs::DirectoryHandle handle;
-
-    if(ext == ""){
-      handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-      }
-    else{
-      handle.open(path + slash + ext, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-      }
-
-    bool file_exists = true;
-    while(file_exists) {
-      Glib::RefPtr<Gnome::Vfs::FileInfo> refFileInfo = handle.read_next(file_exists);
-      if (refFileInfo->get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
-          && ( (refFileInfo->get_name().substr(0,1) != ".") || parent->get_hidden())
-          && refFileInfo->get_name() != "."
-          && refFileInfo->get_name() != ".."
-          ){ 
-        Gtk::MenuItem * subdir;
-        Glib::ustring SubSubCount;
-        if(ext == ""){
-          subdir = Gtk::manage( new Gtk::MenuItem(refFileInfo->get_name() + slash + " "));
-          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                 (path + refFileInfo->get_name()), position,false));
-
-          SubSubCount = CountSubdir(path + refFileInfo->get_name());
-          }
-        else{
-          subdir = Gtk::manage( new Gtk::MenuItem(ext + slash + refFileInfo->get_name() + slash + " "));
-          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                (path + ext.substr(1) + slash + refFileInfo->get_name()), position,false));
-
-          SubSubCount = CountSubdir(path + ext + slash + refFileInfo->get_name());
-          }
-
-        if (SubSubCount != "0"){
-          Gtk::Label * SubSubLabel = Gtk::manage(new class Gtk::Label(SubSubCount + " \342\226\272",1,0.5));
-          SubSubLabel->show();
-          Gtk::MenuItem * subsubdir = Gtk::manage( new Gtk::MenuItem(*SubSubLabel));
-
-          subsubdir->set_right_justified();
-
-          subsubdir->set_events(Gdk::BUTTON_RELEASE_MASK);
-          subsubdir->signal_button_release_event().connect(
-            sigc::bind<int, Glib::ustring, Glib::ustring>(
-              sigc::mem_fun(*this, &DarimasenMenu::SpecialMenuForPath),
-                position, path, ext+ slash + refFileInfo->get_name()));
-
-          MenuArray[position]->attach(*subsubdir, 3 ,4, entry, entry+1);
-          subsubdir->show();
-          MenuArray[position]->attach(*subdir, 0 ,3, entry++, entry+1);
-          subdir->show();
-          }
-        else {
-          MenuArray[position]->attach(*subdir, 0 ,4, entry++, entry+1);
-          subdir->show();            
-          }
-        }
-      }
-    }
-  catch(const Gnome::Vfs::exception& ex){}
-
-
-  }
-
-/**********************/
-
-// the function called for sub-sub-directories - when an arrow is selected in another menu. 
-bool DarimasenMenu::SpecialMenuForPath(GdkEventButton* event,
-       int position,
-       Glib::ustring path,
-       Glib::ustring ext){
-
-  MenuItemArray[position]->remove_submenu();
-  delete MenuArray[position];
-  MenuArray[position] =  new Gtk::Menu();
-  MenuItemArray[position]->set_submenu(*MenuArray[position]);
-  MenuForPath(position, path, ext);
-  MenuItemArray[position]->select();
-
-  needsRebuild[position] = true;
-
-  return true;
-
-  }
-
-/**********************/
-
-void DarimasenMenu:: selection_reset(guint position, Glib::ustring path){
-  if ( needsRebuild[position] ){
-    MenuItemArray[position]->remove_submenu();
-    delete MenuArray[position];
-    MenuArray[position] =  new Gtk::Menu();
-    MenuItemArray[position]->set_submenu(*MenuArray[position]);
-    MenuForPath(position, path, "");
-    MenuItemArray[position]->select();
-
-    needsRebuild[position] = false;
-    }
-}
-
-/**********************/
-
-//Decides the action of the menuItem, more sophisticated than the activate signal. 
-//its comment should always be somewhere.
-
-bool DarimasenMenu::DaMenuSelect(
-      GdkEventButton* event,
-      const Glib::ustring path,
-      guint pos,
-      bool first){
-
-  if ((event->type == GDK_BUTTON_PRESS) && (event->button == 2) ) //middle
-  {
-  parent->newTab(path);
-  return true;
-  }
-  if ((event->type == GDK_BUTTON_PRESS) && (event->button == 1) ) //left
-  {
-  parent->ChangeCurrentPath(path,true,first);
-  return true;
-  }
-  if ((event->type == GDK_BUTTON_PRESS) && (event->button == 3) ) //right
-  {
-
-    for( int i=10; i > 0; i--)
-      prompt.items().pop_back();
-
-
-    //prompt.items().push_back(
-    //  Gtk::Menu_Helpers::MenuElem("Opening " + path + " from here consistently leads to errors"));
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Open In new Tab",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*parent,&Darimasen::newTab),path)));
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::SeparatorElem());
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Copy...",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*this,&DarimasenMenu::copy),path)));
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Move...",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*this,&DarimasenMenu::move),path)));
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Link...",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*this,&DarimasenMenu::link),path)));
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Delete...",
-        sigc::bind<Glib::ustring,gint>(
-          sigc::mem_fun(*this,&DarimasenMenu::unlinkify),path,pos)));
-
-    /*
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::SeparatorElem());
-
-    prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Add to location menu",
-        sigc::bind<Glib::ustring>(
-          sigc::mem_fun(*this,&DarimasenMenu::bookmark),path)));
-    */
-    prompt.signal_selection_done().connect_notify(
-      sigc::mem_fun(*MenuItemArray[pos],&Gtk::MenuItem::deselect));
-
-	
-    prompt.popup(event->button, event->time);
-  return true;
-   }
-
-  return false;
-
-  //DaFileLister(); //5:45pm, 24 Dec 2004, it worked! // leave this comment    
-  }
-
-/**********************/
-
-void DarimasenMenu::bookmark(Glib::ustring path){
-  }
-
-/**********************/
-
-void DarimasenMenu::copy(Glib::ustring path){
-
-  Gtk::Dialog copyDialogue;
-  Gtk::Button * cancelbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-  Gtk::Button * okbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   
-  Gtk::RadioButton::Group _RadioBGroup_radiobutton4;
-  Gtk::RadioButton * radiobutton4 = Gtk::manage(
-    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy Directory to ... (cp -R)"));
-  Gtk::RadioButton * radiobutton5 = Gtk::manage(
-    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy files in directory to ... (cp *)"));
-  Gtk::RadioButton * radiobutton6 = Gtk::manage(
-    new class Gtk::RadioButton(_RadioBGroup_radiobutton4, "Copy everything in directory to ... (cp -R \*)"));
-  Gtk::Entry * entry2 = Gtk::manage(new class Gtk::Entry());
-  cancelbutton2->set_flags(Gtk::CAN_FOCUS);
-  cancelbutton2->set_flags(Gtk::CAN_DEFAULT);
-  okbutton2->set_flags(Gtk::CAN_FOCUS);
-
-  copyDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  radiobutton4->set_flags(Gtk::CAN_FOCUS);
-  radiobutton5->set_flags(Gtk::CAN_FOCUS);
-  radiobutton6->set_flags(Gtk::CAN_FOCUS);
-  entry2->set_flags(Gtk::CAN_FOCUS);
-  entry2->set_editable(true);
-  entry2->set_text(path);
-  copyDialogue.get_vbox()->pack_start(*radiobutton4, Gtk::PACK_SHRINK, 0);
-  copyDialogue.get_vbox()->pack_start(*radiobutton5, Gtk::PACK_SHRINK, 0);
-  copyDialogue.get_vbox()->pack_start(*radiobutton6, Gtk::PACK_SHRINK, 0);
-  copyDialogue.get_vbox()->pack_start(*entry2, Gtk::PACK_SHRINK, 0);
-  copyDialogue.set_title("Copy (Directory)");
-  copyDialogue.set_modal(true);
-
-  copyDialogue.set_resizable(true);
-  copyDialogue.add_action_widget(*cancelbutton2, -6);
-  copyDialogue.add_action_widget(*okbutton2, -5);
-  copyDialogue.show_all_children();
-
-  switch(copyDialogue.run()){
-    case(Gtk::RESPONSE_OK):{
-      parent->set_message( path + "moved");
-  if(radiobutton4->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"cp -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"");
-}
-  if(radiobutton5->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"cp \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"*");
-}
-  if(radiobutton6->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"cp -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry2->get_text().c_str()+ "\"*");
-
-
-}
-      return;
-      }
-    default:{
-      std::cout << path << "not copied\n";
-      return;
-      }
-    }
-  }
-
-/**********************/
-
-void DarimasenMenu::move(Glib::ustring path){
-
-  Gtk::Dialog moveDialogue;
-  Gtk::Button * cancelbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-  Gtk::Button * okbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   
-  Gtk::RadioButton::Group _RadioBGroup_radiobutton1;
-  Gtk::RadioButton * radiobutton1 = Gtk::manage(new class Gtk::RadioButton(
-    _RadioBGroup_radiobutton1, "Move " + path + " to ... (mv -R )"));
-  Gtk::RadioButton * radiobutton2 = Gtk::manage(new class Gtk::RadioButton(
-    _RadioBGroup_radiobutton1, "Move files in directory to... (mv *)"));
-  Gtk::RadioButton * radiobutton3 = Gtk::manage(new class Gtk::RadioButton(
-    _RadioBGroup_radiobutton1, "Move everything in directory to... (mv -R \*)"));
-  Gtk::Entry * entry1 = Gtk::manage(new class Gtk::Entry());
-  cancelbutton1->set_flags(Gtk::CAN_FOCUS);
-  cancelbutton1->set_flags(Gtk::CAN_DEFAULT);
-  okbutton1->set_flags(Gtk::CAN_FOCUS);
-  moveDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  radiobutton1->set_flags(Gtk::CAN_FOCUS);
-  radiobutton2->set_flags(Gtk::CAN_FOCUS);
-  radiobutton3->set_flags(Gtk::CAN_FOCUS);
-  entry1->set_flags(Gtk::CAN_FOCUS);
-  entry1->set_editable(true);
-  entry1->set_text(path);
-  moveDialogue.get_vbox()->pack_start(*radiobutton1, Gtk::PACK_SHRINK, 0);
-  moveDialogue.get_vbox()->pack_start(*radiobutton2, Gtk::PACK_SHRINK, 0);
-  moveDialogue.get_vbox()->pack_start(*radiobutton3, Gtk::PACK_SHRINK, 0);
-  moveDialogue.get_vbox()->pack_start(*entry1, Gtk::PACK_SHRINK, 0);
-  moveDialogue.set_title("Move (Directory)");
-  moveDialogue.set_modal(true);
-  moveDialogue.set_resizable(true);
-  moveDialogue.property_destroy_with_parent().set_value(true);
-  moveDialogue.add_action_widget(*cancelbutton1, -6);
-  moveDialogue.add_action_widget(*okbutton1, -5);
-  moveDialogue.show_all_children();
-
-  switch(moveDialogue.run()){
-    case(Gtk::RESPONSE_OK):{
-      parent->set_message( path + "moved");
-  if(radiobutton1->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"mv -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"");
-}
-  if(radiobutton2->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"mv \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"*");
-}
-  if(radiobutton3->get_active()){
-  Glib::spawn_command_line_async((Glib::ustring)"mv -R \""  + path.c_str() + (Glib::ustring)"\" \"" + entry1->get_text().c_str()+ "\"*");
-
-
-}
-      // rebuild this menu if needed
-      //check if any other menus effected, if so, set for rebuild
-      return;
-      }
-    default:{
-      std::cout << path << "not moved\n";
-      return;
-      }
-    }
-  }
-
-
-/**********************/
-
-void DarimasenMenu::link(Glib::ustring path){
-  Gtk::Dialog linkDialogue;
-  Gtk::Button * cancelbutton3 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-  Gtk::Button * okbutton3 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-  Gtk::Label * label1 = Gtk::manage(new class Gtk::Label("Create link to "+ path +" at ..."));
-  Gtk::Entry * entry3 = Gtk::manage(new class Gtk::Entry());
-  cancelbutton3->set_flags(Gtk::CAN_FOCUS);
-  cancelbutton3->set_flags(Gtk::CAN_DEFAULT);
-  okbutton3->set_flags(Gtk::CAN_FOCUS);
-  linkDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  label1->set_alignment(0,0.5);
-  label1->set_padding(2,2);
-  label1->set_justify(Gtk::JUSTIFY_LEFT);
-  label1->set_line_wrap(true);
-  label1->set_use_markup(false);
-  label1->set_selectable(false);
-  entry3->set_flags(Gtk::CAN_FOCUS);
-  entry3->set_visibility(true);
-  entry3->set_editable(true);
-  entry3->set_text(path);
-  entry3->set_activates_default(false);
-  linkDialogue.get_vbox()->pack_start(*label1, Gtk::PACK_SHRINK, 0);
-  linkDialogue.get_vbox()->pack_start(*entry3, Gtk::PACK_SHRINK, 0);
-  linkDialogue.set_title("Link (Directory)");
-  linkDialogue.set_modal(true);
-  linkDialogue.set_resizable(true);
-  linkDialogue.property_destroy_with_parent().set_value(true);
-  linkDialogue.add_action_widget(*cancelbutton3, -6);
-  linkDialogue.add_action_widget(*okbutton3, -5);
-
-  linkDialogue.show_all_children();
-
-  switch(linkDialogue.run()){
-    case(Gtk::RESPONSE_OK):{
-
-
-  Glib::spawn_command_line_async((Glib::ustring)"ln -s \""  + label1->get_text().c_str() + (Glib::ustring)"\" \"" + entry3->get_text().c_str() + "\"");
-
-      parent->set_message( "link created " + path );
-
-      //check and see if link path is in any menus, set for rebuild if true.
-      return;
-      }
-    default:{
-      std::cout << "No link created " + path << "\n";
-      return;
-      }
-    }
-  }
-
-/**********************/
-
-
-void DarimasenMenu::unlinkify(Glib::ustring path, gint menu){
-  Gtk::Dialog unlinkifyDialogue;
-  Gtk::Button * cancelbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-  Gtk::Button * okbutton4 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-  Gtk::Label * label2 = Gtk::manage(
-    new class Gtk::Label("Are you sure you want to delete " + path + " and its contents?"));
-  cancelbutton4->set_flags(Gtk::CAN_FOCUS);
-  cancelbutton4->set_flags(Gtk::CAN_DEFAULT);
-  okbutton4->set_flags(Gtk::CAN_FOCUS);
-  unlinkifyDialogue.get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  label2->set_alignment(0,0.5);
-  label2->set_padding(2,2);
-  label2->set_justify(Gtk::JUSTIFY_LEFT);
-  label2->set_line_wrap(true);
-  unlinkifyDialogue.get_vbox()->pack_start(*label2, Gtk::PACK_SHRINK, 0);
-  unlinkifyDialogue.set_title("Delete (Directory)");
-  unlinkifyDialogue.set_modal(true);
-  unlinkifyDialogue.property_window_position().set_value(Gtk::WIN_POS_NONE);
-  unlinkifyDialogue.set_resizable(true);
-  unlinkifyDialogue.property_destroy_with_parent().set_value(true);
-  unlinkifyDialogue.add_action_widget(*cancelbutton4, -6);
-  unlinkifyDialogue.add_action_widget(*okbutton4, -5);
-  unlinkifyDialogue.show_all_children();
-
-  switch(unlinkifyDialogue.run()){
-    case(Gtk::RESPONSE_OK):{
-
-      Glib::spawn_command_line_async((Glib::ustring)"rm -Rf \""  + path + "\"");
-      needsRebuild[menu] = true;
-      //check if any of the windows contain that path, do what? 
-      parent->set_message("Deleted " + path); 
-      return;
-      }
-    default:{
-      parent->set_message("nothing deleted");
-      return;
-      }
-    }
-  }
-
-/**********************/
-
-// provides the numbers by the arrows. 
-Glib::ustring DarimasenMenu::CountSubdir(const Glib::ustring& path){
-  int j=0;
-  try{
-    Gnome::Vfs::DirectoryHandle handle;
-    handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-
-    bool file_exists = true;
-    while(file_exists){
-
-      Glib::RefPtr<Gnome::Vfs::FileInfo> refFileInfo = handle.read_next(file_exists);
-      if (refFileInfo->get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
-        && ( (refFileInfo->get_name().substr(0,1) != ".") || parent->get_hidden())
-        && refFileInfo->get_name() != "."
-        && refFileInfo->get_name() != ".."){
-        j++;
-        }
-      }
-    }
-  catch(const Gnome::Vfs::exception& ex){}
-  return int2ustr(j);
-
-}
-
-/**********************/
-
-// parses the path, builds the menu bar. 
-DarimasenMenu::DarimasenMenu(const Glib::ustring & path, Darimasen& Myparent, guint pos){
-
-  depth = 0;
-
-  Glib::ustring shortpath = path; //home = Glib::get_home_dir();
-
-  parent = &Myparent;
-  
-  int startPos = 0 , i = 0;
-
-
-  if ( path.find(Glib::get_home_dir()) != Glib::ustring::npos ){
-    shortpath.replace(0,((Glib::ustring)Glib::get_home_dir()).length(),"~");
-    }
-
-  while ( (shortpath.find(slash,startPos) != Glib::ustring::npos) ) {
-    startPos = shortpath.find(slash,startPos) + 1; depth++;
-    }
-
-  menulevel =  new Glib::ustring[depth+1];
-  needsRebuild = new bool[depth+1];
-  for( int i=0; i<=depth; i++)
-        needsRebuild[i] = false;
-
-
-  startPos = 0;
-  for(i = 0; shortpath.find(slash,startPos) !=  Glib::ustring::npos ; i++ ){
-    menulevel[i] = shortpath.substr(startPos,shortpath.find(slash,startPos) - startPos + 1 );
-    startPos = shortpath.find(slash,startPos) + 1;
-    };
-  menulevel[depth] = ".";
-
-  MenuArray = new Gtk::Menu*[depth+1];
-  MenuItemArray = new Gtk::MenuItem*[depth+1];
-
-  for(int c = 0; c < depth+1; c++){
-    MenuArray[c] =  new Gtk::Menu();
-    }
- 
-    Glib::ustring subin = CountSubdir(path);
-    if ( subin != "0" ){
-      MenuItemArray[depth] =  new Gtk::MenuItem( subin + " \342\226\272" );
-      MenuItemArray[depth]->show();
-      MenuItemArray[depth]->set_submenu(*MenuArray[depth]);
-      prepend(*MenuItemArray[depth]);
-      MenuForPath(depth, path, "");
-      }
-  
-  Glib::ustring crop = path;
-
-
-  for(i = depth - 1; i>0; i--){
-    crop = crop.substr(0, crop.rfind(slash,crop.length()-2)) + slash;
-
-    MenuItemArray[i] = new Gtk::MenuItem(underscore_safe(menulevel[i]) );
-    MenuItemArray[i]->show();
-    MenuItemArray[i]->set_submenu(*MenuArray[i]);
-    prepend(*MenuItemArray[i]);
-    MenuForPath(i, crop, "");
-    }
-
-  MenuItemArray[i] = new Gtk::MenuItem(underscore_safe(menulevel[i] ));
-  MenuItemArray[i]->show();
-  prepend(*MenuItemArray[i]);
-
-
-
-// root stuff
-    MenuItemArray[0]->set_submenu(*MenuArray[0]);
-    MenuItemArray[0]->show();
-    MenuArray[0]->show();
-
-    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem("/ (root)"));
-    MenuArray[0]->attach(*subdir, 0 ,1, 0, 1);
-    subdir->show();
-
-          subdir->set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                 "/",pos,false));
-
-
-
-    Gtk::MenuItem * subdir2 = Gtk::manage( new Gtk::MenuItem("~ (home)"));
-    MenuArray[0]->attach(*subdir2, 0 ,1, 1, 2);
-    subdir2->show();
-
-          subdir2->set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir2->signal_button_press_event().connect(
-            sigc::bind<Glib::ustring,guint,bool>(
-              sigc::mem_fun(*this, &DarimasenMenu::DaMenuSelect),
-                Glib::get_home_dir(),pos,false));
-
-    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
-    MenuArray[0]->attach(*sep, 0 ,1, 2, 3);
-    sep->show();
-
-    Gtk::MenuItem * subdir3 = Gtk::manage( new Gtk::MenuItem("Add a location to this list"));
-    MenuArray[0]->attach(*subdir3, 0 ,1, 3, 4);
-    subdir3->set_sensitive(false);
-    subdir3->show();
-
-
-  show();
-
-  }
-
-/**********************/
-
-// cleanup on asile 9. More might me Gtk::manageable...
-DarimasenMenu::~DarimasenMenu(){
-  for(int c = 0; c < depth+1; c++){
-    delete MenuArray[c];
-    }
-  delete menulevel;
-  delete needsRebuild;
-  for (int i = 0; i <=depth; i++){
-    delete MenuArray[i];
-    delete MenuItemArray[i];
-    }
-  
-  }
-
-/**********************/
-
-

Deleted: trunk/src/damenu.h
===================================================================
--- trunk/src/damenu.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/damenu.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,50 +0,0 @@
-/* Darimasen - damenu.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-#ifndef DAMENU_H
-#define DAMENU_H
-
-/**********************/
-
-#include "main.h"
-#include "darimasen.h"
-
-/**********************/
-
-class DarimasenMenu : public Gtk::MenuBar {
-
-public:
-
-  DarimasenMenu(const Glib::ustring&, class Darimasen&, guint);
-  ~DarimasenMenu();
-
-private:
-
-  class Darimasen * parent;
-  int depth;
-  Gtk::Menu ** MenuArray; 
-  Gtk::MenuItem ** MenuItemArray;
-  Glib::ustring * menulevel;
-  Gtk::Menu prompt;
-
-
-  void bookmark(Glib::ustring);
-  void copy(Glib::ustring);
-  Glib::ustring CountSubdir(const Glib::ustring&);
-  bool DaMenuSelect(GdkEventButton*, const Glib::ustring,guint,bool);
-  void link(Glib::ustring);
-  void MenuForPath(int, Glib::ustring , Glib::ustring);
-  void move(Glib::ustring);
-  bool * needsRebuild;
-  bool SpecialMenuForPath(GdkEventButton* , int, Glib::ustring  , Glib::ustring);
-  void selection_reset(guint, Glib::ustring);
-  void unlinkify(Glib::ustring,gint);
-
-public:
-
-  void signal_deactivate ();
-
-  };
-
-/**********************/
-
-#endif //DAMENU_H

Deleted: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/darimasen.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,574 +0,0 @@
-/* Darimasen - darimasen.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "darimasen.h"
-
-/**********************/
-
-Darimasen::Darimasen(std::vector<Glib::ustring> paths){
-  set_title("Darimasen");
-  set_default_size(500, 330);
-
-  mode = 0;
-
-  try{
-     windowIcon = Gdk::Pixbuf::create_from_file("/usr/share/icons/hicolor/48x48/apps/darimasen.png");
-    set_icon(windowIcon);
-    }
-  catch(const Glib::Error) {
-    try{
-      windowIcon = Gdk::Pixbuf::create_from_file("../pixmaps/48x48/darimasen.png");
-      set_icon(windowIcon);
-      }
-    catch(const Glib::Error) {}
-    }
-
-  add(VerticalOrganizer);
-  VerticalOrganizer.show();
-
-  VerticalOrganizer.pack_start(TopBar, Gtk::PACK_SHRINK);
-  TopBar.show();
-
-  TopBar.set_toolbar_style(Gtk::TOOLBAR_ICONS); 
-
-
-  CompactMenuContainer = new Gtk::ToolItem;
-  TopBar.append(*CompactMenuContainer);
-  CompactMenuContainer->show();
-
-  CompactMenu = new Gtk::MenuBar;
-  m_Menu_File = new Gtk::Menu;
-
-
-
-  CompactMenu->items().push_back(Gtk::Menu_Helpers::MenuElem(
-    "\342\226\274", *m_Menu_File));
-
-  // glade-- told me to do it....
-  m_Menu_File->items().push_back(Gtk::Menu_Helpers::CheckMenuElem(
-    "Show Hidden",Gtk::AccelKey(GDK_H, Gdk::CONTROL_MASK),
-      sigc::mem_fun(*this, &Darimasen::fShowHidden)));
-
-  optShowHidden = (Gtk::CheckMenuItem *)&m_Menu_File->items().back();
-
-  m_Menu_File->items().push_back(Gtk::Menu_Helpers::MenuElem(
-    "Print history to Terminal",Gtk::AccelKey(GDK_P, Gdk::CONTROL_MASK),
-      sigc::mem_fun(*this, &Darimasen::fPrintHist)));
-
-  m_Menu_File->items().push_back( Gtk::Menu_Helpers::MenuElem("About...",
-    sigc::mem_fun(*this, &Darimasen::fAbout) ) );
-
-  m_Menu_File->items().push_back( Gtk::Menu_Helpers::SeparatorElem() ) ;
-
-  m_Menu_File->items().push_back( Gtk::Menu_Helpers::StockMenuElem(Gtk::Stock::QUIT,
-    sigc::mem_fun(*this, &Darimasen::fQuit) ) );
-    
-  TopBar.set_show_arrow(false);
-  CompactMenuContainer->add(*CompactMenu); 
-  CompactMenu->show();
-
-
-  Gtk::SeparatorToolItem * sep1 = new Gtk::SeparatorToolItem;
-  TopBar.append(*sep1);
-  sep1->show();
-
-  DarimasenMenuContainer = new Gtk::ToolItem;
-  TopBar.append(*DarimasenMenuContainer);
-  DarimasenMenuContainer->set_expand(true);
-  DarimasenMenuContainer->show();
-
-  Gtk::SeparatorToolItem * sep2  = new Gtk::SeparatorToolItem;
-  TopBar.append(*sep2);
-  sep2->show();
-
-  BackButton = new Gtk::MenuToolButton(Gtk::StockID("gtk-go-back"));
-  BackButton->signal_clicked().connect(sigc::mem_fun(*this, &Darimasen::fBack));
-  TopBar.append(*BackButton);
-  BackButton->set_sensitive(false);
-  BackButton->show();
-  
-  ChangeIconMode = new Gtk::ToolButton(Gtk::StockID("gtk-convert"));
-  ChangeIconMode->signal_clicked().connect(sigc::mem_fun(*this, &Darimasen::fChangeIconMode));
-  TopBar.append(*ChangeIconMode);
-  //ChangeIconMode->set_sensitive(false);
-  ChangeIconMode->show();
-   
-  //ViewTree = new Gtk::ToggleToolButton(Gtk::StockID("gtk-index"));
-  //ViewTree->signal_clicked().connect(sigc::mem_fun(*this, &Darimasen::fViewTree));
-  //TopBar.append(*ViewTree);
-  //ViewTree->set_sensitive(false);
-  //ViewTree -> show();
-
-  NewTab = new Gtk::ToolButton(Gtk::StockID("gtk-new"));
-  NewTab->signal_clicked().connect(sigc::mem_fun(*this, &Darimasen::fNewTab));
-  TopBar.append(*NewTab);
-  NewTab->show();
-
-  VerticalOrganizer.add(HideTreePane);
-  HideTreePane.show();
-
-  HideTreePane.pack1(TreeScroller, Gtk::SHRINK);
-
-  Tabber = new Gtk::Notebook;
-  Tabber->signal_switch_page().connect(sigc::mem_fun(*this, &Darimasen::tabberSwitched));
-  Tabber->set_show_border(false);
-  Tabber->show();
-
-  HideTreePane.pack2(*Tabber, Gtk::EXPAND|Gtk::SHRINK);
-   
-  Info.set_has_resize_grip();
-  Info.show();
-  VerticalOrganizer.pack_start(Info, Gtk::PACK_SHRINK);
-
-  show();
-
-  for(int i = 0; i < paths.size(); i++){
-    set_history(i,paths[i]);
-    addTab(Tabber->get_n_pages());
-    }
-
-
-  myOptions = new optionsQuery(Glib::get_home_dir() + get_choices_dir() + "/Darimasen/Options");
- }
-
-/**********************/
-
-Darimasen::~Darimasen(){
-  fQuit();
-  }
-
-/**********************/
-
-// all the stuff for a well rounded tab
-void Darimasen::addTab(guint pos){
-
-  if( Tabber->get_n_pages() == 0 )
-    Tabber->set_show_tabs(false);
-  else
-    Tabber->set_show_tabs(true);
-
-
-  Gtk::Image * xed = 
-    new Gtk::Image("/usr/share/icons/hicolor/16x16/stock/generic/stock_close.png");
-  xed->show();
-
-  Gtk::Label * tabNum;
-
-  if ( get_history(pos) == slash)
-    tabNum = new Gtk::Label(slash + " ");
-  else if ( get_history(pos) == (Glib::get_home_dir() + slash))
-    tabNum = new Gtk::Label("~ ");
-  else
-    tabNum = new Gtk::Label(
-      get_history(pos).substr(get_history(pos).rfind(slash,get_history(pos).length() - 2  ) + 1));
-
-
-  Gtk::HBox * arrangement= new Gtk::HBox() ;
-  Gtk::Button * closeButton = new Gtk::Button();
-
-  closeButton->add(*xed);
-  closeButton->set_relief(Gtk::RELIEF_NONE); 
-  closeButton->show();
-
-
-
-
-  tabNum->show();
-  arrangement->show();
-
-  arrangement->pack_start(*tabNum);
-  arrangement->pack_end(*closeButton);
-
-  Gtk::EventBox * MainEventBox = new class Gtk::EventBox;
-
-
-  MainEventBox->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
-  MainEventBox->show();
-
-  DaIconModes * foo;
-  foo = new class DaIconModes(pos, *this);
-
-
-  // pos can't be the thing passed here, it changes... (segfault: 3 tabs, close 2nd then 3rd)
-  closeButton->signal_clicked().connect(
-    sigc::bind<DaIconModes*>(sigc::mem_fun(*this, &Darimasen::removeTab), foo) );
-
-
-
-  if ( IconModeList.size() == pos ){
-    IconModeList.push_back(foo);
-    EventBoxList.push_back(MainEventBox);
-    }
-  else {
-    delete IconModeList[pos];
-    IconModeList[pos] = foo;
-    delete EventBoxList[pos];
-    EventBoxList[pos] = MainEventBox;
-    }
-
-  Gtk::ScrolledWindow * MainScroller = new Gtk::ScrolledWindow;
-  MainScroller->show();
-  MainScroller->set_shadow_type(Gtk::SHADOW_NONE);
-  MainScroller->add(*MainEventBox);
-  MainEventBox->add(*foo);
-  MainScroller->set_policy(Gtk::POLICY_ALWAYS, Gtk::POLICY_AUTOMATIC);
-  foo->show();
-  Tabber->insert_page( *MainScroller, *arrangement, pos);
-  }
-
-/**********************/
-
-void Darimasen::fAbout(){
-
-  about = new Gtk::Window();
-
-  Gtk::Image * image1;
-  try{
-    image1 = new class Gtk::Image(  Gdk::Pixbuf::create_from_file( 
-      "/usr/share/pixmaps/darimasenInfo.svg" ) );
-    }
-  catch(const Glib::Error) {
-    try{
-    image1 = new class Gtk::Image(  Gdk::Pixbuf::create_from_file( 
-      "../pixmaps/darimasenInfo.svg" ) );
-      }
-  catch(const Glib::Error) {}
-    }
-
-
-  Gtk::EventBox * closer = new Gtk::EventBox;
-  closer->add(*image1);
-  closer->signal_button_press_event().connect(
-    sigc::mem_fun(*this, &Darimasen::fAbout_ch0wned));
-
-  about->add(*closer);
-  about->set_title("About Darimasen");
-  about->set_modal(true);
-  about->set_resizable(false);
-  about->set_decorated (false);
-  about->set_position(Gtk::WIN_POS_CENTER);
-
-  about->show_all_children();
-
-
-  Gtk::Main::run(*about); 
-
-  delete image1;
-  delete closer;
-  delete about;
-  }
-
-/**********************/
-
-bool Darimasen::fAbout_ch0wned(GdkEventButton*){
-  about->hide();
-  }
-
-/**********************/
-
-void Darimasen::fBack(){
-  del_history(Tabber->get_current_page());
-
-  ChangeCurrentPath(get_history(Tabber->get_current_page()),false,false);
-
-  if (history[Tabber->get_current_page()].size() == 1)
-    BackButton->set_sensitive(false);
-  }
-
-/**********************/
-
-void Darimasen::fChangeIconMode(){
-  mode = (mode + 1) % 3; // increment, mod of possibilities.
-  for(int i = 0; i < history.size(); i++){
-      ChangeCurrentPath(get_history(i),false,false);
-    } 
-  }
-
-/**********************/
-
-// anything prefixed with 'f' corresponds with a button. 'nuff said.
-void Darimasen::fNewTab(){
-  set_history(Tabber->get_n_pages(), Glib::get_home_dir() + slash);
-  addTab(Tabber->get_n_pages());
-  }
-
-/**********************/
-
-void Darimasen::fPrintHist(){
-  std::vector< std::vector<Glib::ustring> > destroy = history;
-  
-  std::cout << "There are " << destroy.size() << " tabs here.\n";
-  
-  for (int i = 0; i < destroy.size(); i++){
-    for (; destroy[i].size() > 0; destroy[i].pop_back()){
-      std::cout << "history[" << i << "].end() = " << destroy[i][destroy[i].size() -1] << "\n";
-      }
-    }
-  }
-
-/**********************/
-
-void Darimasen::fQuit(){
-
-  delete Tabber;
-
-  delete BackButton;
-  delete ChangeIconMode;
-  //delete ViewTree;
-  delete NewTab;
-  DarimasenMenuContainer->remove();
-
-  delete DarimasenMenuContainer;
-  delete m_Menu_File;
-  delete CompactMenu;
-  delete CompactMenuContainer;
-
-  windowIcon.clear();
-  for (int i=0; i < IconModeList.size(); i++){
-     delete IconModeList[i];
-     delete EventBoxList[i];
-     }
-
-  delete myOptions;
-
-  hide();
-  }
-
-/**********************/
-
-void Darimasen::fShowHidden(){
-  DarimasenMenuContainer->remove();
-  DaMenu = Gtk::manage( new DarimasenMenu(
-    get_history(Tabber->get_current_page()), *this, Tabber->get_current_page()));
-  DarimasenMenuContainer->add(*DaMenu);
-
-  for( int i = 0; IconModeList.size() > i; i++)
-    IconModeList[i]->SwitchHidden(i);
-  }
-
-/**********************/
-
-// removing a tab has some cleanup involved...
-void Darimasen::removeTab(DaIconModes*& toRemove){
-
-  guint pos = toRemove->get_position();
-
-  if( Tabber->get_n_pages() == 2 )
-    Tabber->set_show_tabs(false);
-  else
-    Tabber->set_show_tabs(true);
-
-  guint tmp = pos;
-  Tabber->remove_page(pos);
-  
-  while ( del_history(pos) > 0 );
-
-  delete IconModeList[pos];
-  IconModeList.erase(IconModeList.begin()+pos,IconModeList.begin()+pos+1 );
-
-  delete EventBoxList[pos];
-  EventBoxList.erase(EventBoxList.begin()+pos,EventBoxList.begin()+pos+1 );
-
-  for(guint i = 0; i < Tabber->get_n_pages(); i++){
-    IconModeList[i]->update_position(i);
-    std::cout << i << "\n";
-    }
-  }
-
-/**********************/
-
-// this is for a signal handler.
-void Darimasen::tabberSwitched(GtkNotebookPage* sig, guint n){
-
-
-  DarimasenMenuContainer->remove();
-  DaMenu = Gtk::manage(new class DarimasenMenu(get_history(n), *this, n));
-  DarimasenMenuContainer->add(*DaMenu);
-
-  if (history[n].size() == 1)
-    BackButton->set_sensitive(false);
-  else
-    BackButton->set_sensitive(true);
-
-  buildHistoryMenu(n);
-  }
-
-/**********************/
-
-void Darimasen::buildHistoryMenu(gint tab){
-  if(BackButton->get_menu() != NULL){
-    delete BackButton->get_menu();
-    }
-
-  history_menu = new Gtk::Menu();
-  BackButton->set_menu(*history_menu);
-
-  for( int i = 1; i <  history[tab].size(); i++){
-    history_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(
-      get_history(tab,i),sigc::bind<gint,gint>(sigc::mem_fun(*this, &Darimasen::fHistoryMenu), tab, i)));
-    }
-  }
-
-/**********************/
-
-// changing directories actually is making a new tab to substitute for the old one.
-void Darimasen::ChangeCurrentPath(Glib::ustring pathin, bool addPath, bool menuOnly){
-  guint nth = Tabber->get_current_page();
-
-  if (addPath && !menuOnly){
-    if (pathin.substr(pathin.length()-1) != "/")
-      set_history(nth, pathin + slash);
-    else
-      set_history(nth, pathin);
-    }
-
-  if  (!menuOnly){
-    if ( history[nth].size() > 1)
-      BackButton->set_sensitive(true);
-    else
-      BackButton->set_sensitive(false);
-
-      Tabber->remove_page(nth);
-      addTab(nth);
-      Tabber->set_current_page(nth);
-    }
-
-  DarimasenMenuContainer->remove();
-  DaMenu = Gtk::manage( new DarimasenMenu( get_history(nth), *this,nth));
-  DarimasenMenuContainer->add(*DaMenu);
-
-  }
-
-/**********************/
-
-bool Darimasen::del_history(gint tab){
-  history[tab].pop_back();
-  if ( history[tab].size() == 0 ){
-    history.erase(history.begin()+tab,history.begin()+tab+1 );
-    return 0;
-    }
-  return history[tab].size();
-  }
-
-/**********************/
-
-bool Darimasen::get_hidden(){
-  return optShowHidden->get_active();
-  }
-
-/**********************/
-
-Glib::ustring Darimasen::get_history(gint tab, gint level){
-  return history[tab][history[tab].size()-level-1];
-  }
-
-/**********************/
-
-Glib::RefPtr<Gdk::Pixbuf> Darimasen::get_icon(Glib::ustring mime){
-  int i;
-
-  for(i = 0; i< mimeList.size(); i++){
-    if( mime == mimeList[i] ){
-      return unsizedImg[i];
-      }
-    }
-   // pic doesn't exist.
-
-    Glib::ustring ico;
-  try{
-    ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
-    ico += mime.replace(mime.find("/"), 1, "-");
-    ico += ".png";
-
-    Glib::file_get_contents(ico);
-    }
-  catch(const Glib::Error) {
-    try{
-      ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
-      ico += mime.substr(0,mime.find("-"));
-      ico += ".png";
-      Glib::file_get_contents(ico);
-      }
-    catch(const Glib::Error) {
-     ico = "/usr/share/icons/gnome/48x48/filesystems/gnome-fs-loading-icon.png";
-     }
-    }
-
-  mimeList.push_back(mime);
-  Glib::RefPtr<Gdk::Pixbuf> xe = Gdk::Pixbuf::create_from_file(ico);
-  unsizedImg.push_back(xe);
-  return unsizedImg[i]; 
-  }
-
-/**********************/
-
-short Darimasen::get_mode(){
-  return mode;
-  }
-
-/**********************/
-
-void Darimasen::fHistoryMenu(gint tab, gint iterations){
-  for(int i = 0; i < iterations; i++)
-    del_history(Tabber->get_current_page());
-
-  ChangeCurrentPath(get_history(Tabber->get_current_page()),false,false);
-
-  if (history[Tabber->get_current_page()].size() == 1)
-    BackButton->set_sensitive(false);
-  }
-
-/**********************/
-
-// ...and there was already one with an f.
-void Darimasen::newTab(Glib::ustring newpath){
-  if( newpath.substr(newpath.length() - 1) != slash)
-    newpath += slash;
-
-  set_history(Tabber->get_n_pages(), newpath);
-  addTab(Tabber->get_n_pages());
-  }
-
-/**********************/
-
-void Darimasen::set_message(Glib::ustring in){
-  Info.pop();
-  Info.push(in);
-  }
-
-/**********************/
-
-void Darimasen::set_history(gint tab, Glib::ustring path){
-  if (Tabber->get_n_pages() == tab){
-    std::vector<Glib::ustring> empty;
-    history.push_back(empty);
-    history[tab].push_back(path);
-    }
-  else {
-    history[tab].push_back(path);
-    }
-  }
-
-/**********************/
-
-// this is called on file operations - since there is more then one tab,
-// all of them should be checked to see if they should be updated.
-void Darimasen::updateView(Glib::ustring sourceDir, Glib::ustring targetDir){
-
-  for(int i = 0; i < history.size(); i++){
-    if( get_history(i) == sourceDir || get_history(i) == targetDir ){
-
-/*
-if (!Gnome::Vfs::Uri::create(get_history(i))->uri_exists()){
-  Glib::ustring temp = get_history(i);
-  del_history(i);
-  set_history(i, temp.substr(0, temp.rfind(slash)) + slash);
-}*/
-
-      ChangeCurrentPath(get_history(i),false,false);
-      }
-    }
-  }
-
-/**********************/

Deleted: trunk/src/darimasen.h
===================================================================
--- trunk/src/darimasen.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/darimasen.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,118 +0,0 @@
-/* Darimasen - darimasen.h - Copyright (C) 2004 - 2005 Sudrien, GPL
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-
-#ifndef DARIMASEN_H
-#define DARIMASEN_H
-
-/**********************/
-
-#include "main.h"
-#include <sys/types.h>
-#include <gtkmm/menutoolbutton.h>
-
-#include "optionsManager.h"
-#include "damenu.h"
-#include "iconmodes.h"
-
-/**********************/
-
-class Darimasen : public Gtk::Window {
-
-public:
-
-  Darimasen(std::vector<Glib::ustring>);
-  ~Darimasen();
-
-private:
-
-  Glib::RefPtr<Gdk::Pixbuf> windowIcon;
-  short mode;
-
-
-  Gtk::VBox VerticalOrganizer;
-  Gtk::Toolbar TopBar;
-
-  Gtk::ToolItem * CompactMenuContainer;
-  Gtk::MenuBar * CompactMenu;
-  Gtk::Menu * m_Menu_File;
-  Gtk::CheckMenuItem * optShowHidden;
-
-  Gtk::SeparatorToolItem * sep1;
-
-  Gtk::ToolItem * DarimasenMenuContainer;
-  class DarimasenMenu * DaMenu;
-
-  Gtk::SeparatorToolItem * sep2;
-
-  Gtk::MenuToolButton * BackButton;
-  Gtk::Menu * history_menu;
-  Gtk::ToolButton * ChangeIconMode;
-  //Gtk::ToggleToolButton * ViewTree;
-  Gtk::ToolButton * NewTab;
-
-  Gtk::HPaned HideTreePane;
-  Gtk::ScrolledWindow TreeScroller;
-  Gtk::Notebook * Tabber;
-
-  Gtk::Statusbar Info;
-
-
-  std::vector< class DaIconModes* > IconModeList;
-  std::vector< class Gtk::EventBox* > EventBoxList;
-  std::vector< std::vector<Glib::ustring> > history;
-  std::vector <Glib::ustring> mimeList;
-  std::vector <Glib::RefPtr<Gdk::Pixbuf> > unsizedImg;
-
-  class optionsQuery * myOptions;
-
-Gtk::Window * about;
-
-  void addTab(guint);
-  void fAbout();
-  bool fAbout_ch0wned(GdkEventButton*);
-  void fBack();
-  void fChangeIconMode();
-  void fNewTab();
-  void fPrintHist();
-  void fQuit();
-  void fShowHidden();
-  void removeTab(DaIconModes*&);
-  void tabberSwitched(GtkNotebookPage*, guint);
-
-
-public:
-
-
-  void buildHistoryMenu(gint);
-  //rework so the bools mean somthing consistant
-  void ChangeCurrentPath(Glib::ustring path, bool, bool);
-  bool del_history(gint);
-  bool get_hidden();
-  Glib::ustring get_history(gint, gint = 0);
-  Glib::RefPtr<Gdk::Pixbuf> get_icon(Glib::ustring mime);
-  short get_mode();
-  void fHistoryMenu(gint, gint);
-  void newTab(Glib::ustring);
-  void set_message(Glib::ustring);
-  void set_history(gint, Glib::ustring);
-  void updateView(Glib::ustring, Glib::ustring);
-
-  };
-
-/**********************/
-
-#endif //DARIMASEN_H

Deleted: trunk/src/firsttime.cpp
===================================================================
--- trunk/src/firsttime.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/firsttime.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,147 +0,0 @@
-/* Darimasen - firsttime.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "firsttime.h"
-
-/**********************/
-
-firsttime::firsttime(){  
-
-   okbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   image1 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-dialog-question"), Gtk::IconSize(6)));
-   label1 = Gtk::manage(new class Gtk::Label("It looks like this is your first time\n"
-		"running Darimasen (and you \n"
-		"have not used ROX).\n\n"
-		"This is a good time to set up\n"
-		"some default \"Run Actions\"\n\n"
-		"Simply replace the wildcard (*)\n"
-		"with your preferred program."));
-   hbox1 = Gtk::manage(new class Gtk::HBox(false, 0));
-   textlabel = Gtk::manage(new class Gtk::Label("Text Files:"));
-   musiclabel = Gtk::manage(new class Gtk::Label("Music Files:"));
-   videolabel = Gtk::manage(new class Gtk::Label("Video Files:"));
-   imagelabel = Gtk::manage(new class Gtk::Label("Image Files:"));
-   textentry = Gtk::manage(new class Gtk::Entry());
-   musicentry = Gtk::manage(new class Gtk::Entry());
-   videoentry = Gtk::manage(new class Gtk::Entry());
-   imageentry = Gtk::manage(new class Gtk::Entry());
-   table1 = Gtk::manage(new class Gtk::Table(2, 2, false));
-   hbox2 = Gtk::manage(new class Gtk::HBox(false, 0));
-   vbox1 = Gtk::manage(new class Gtk::VBox(false, 0));
-   okbutton1->set_flags(Gtk::CAN_FOCUS);
-   okbutton1->set_flags(Gtk::CAN_DEFAULT);
-   okbutton1->set_relief(Gtk::RELIEF_NORMAL);
-   get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-   image1->set_alignment(0.5,0.5);
-   image1->set_padding(6,0);
-   label1->set_alignment(0.5,0.5);
-   label1->set_padding(0,0);
-   label1->set_justify(Gtk::JUSTIFY_LEFT);
-   label1->set_line_wrap(true);
-   label1->set_use_markup(false);
-   label1->set_selectable(false);
-   hbox1->pack_start(*image1, Gtk::PACK_SHRINK, 0);
-   hbox1->pack_start(*label1);
-
-   textlabel->set_alignment(0.96,0.5);
-
-   textentry->set_flags(Gtk::CAN_FOCUS);
-   textentry->set_text("* \"$@\"");
-
-   musicentry->set_flags(Gtk::CAN_FOCUS);
-   musicentry->set_text("* \"$@\"");
-
-   videoentry->set_flags(Gtk::CAN_FOCUS);
-   videoentry->set_text("* \"$@\"");
-
-   imageentry->set_flags(Gtk::CAN_FOCUS);
-   imageentry->set_text("* \"$@\"");
-
-   table1->set_border_width(2);
-   table1->set_row_spacings(5);
-   table1->set_col_spacings(4);
-   table1->attach(*textlabel, 0, 1, 0, 1, Gtk::FILL);
-   table1->attach(*musiclabel, 0, 1, 1, 2, Gtk::FILL);
-   table1->attach(*videolabel, 0, 1, 2, 3, Gtk::FILL);
-   table1->attach(*imagelabel, 0, 1, 3, 4, Gtk::FILL);
-   table1->attach(*textentry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*musicentry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*videoentry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL);
-   table1->attach(*imageentry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL);
-   hbox2->pack_start(*table1);
-   vbox1->pack_start(*hbox1);
-   vbox1->pack_start(*hbox2);
-
-   get_vbox()->pack_start(*vbox1);
-   set_title("Darimasen: first run");
-
-
-   add_action_widget(*okbutton1, -5);
-
-
-   okbutton1->signal_clicked().connect(sigc::mem_fun(*this, &firsttime::confirm));
-
-
-   show_all_children();
-  }
-
-
-/**********************/
-
-void firsttime::confirm(){
-
-  Glib::ustring choicesdir="/.choices";
-
-  if ( textentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + textentry->get_text() + "\n";
-    try {
-      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/text"));
-      Gnome::Vfs::Handle write_handle;
-      write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
-      write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
-      GnomeVFSFileSize bytes_written = write_handle.write(command.data(), command.size());
-      }
-    catch(const Gnome::Vfs::exception) {}
-    }
-
-  if ( musicentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + musicentry->get_text() + "\n";
-    try {
-      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/audio"));
-      Gnome::Vfs::Handle write_handle;
-      write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
-      write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
-      GnomeVFSFileSize bytes_written = write_handle.write(command.data(), command.size());
-      }
-    catch(const Gnome::Vfs::exception) {}
-    }
-
-  if ( videoentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + videoentry->get_text() + "\n";
-    try {
-      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/video"));
-      Gnome::Vfs::Handle write_handle;
-      write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
-      write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
-      GnomeVFSFileSize bytes_written = write_handle.write(command.data(), command.size());
-      }
-    catch(const Gnome::Vfs::exception) {}
-    }
-
-  if ( imageentry->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec " + imageentry->get_text() + "\n";
-    try {
-      Glib::ustring exec1 = (Glib::get_home_dir() +  (Glib::ustring)(choicesdir + "/MIME-types/image"));
-      Gnome::Vfs::Handle write_handle;
-      write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
-      write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
-      GnomeVFSFileSize bytes_written = write_handle.write(command.data(), command.size());
-      }
-    catch(const Gnome::Vfs::exception) {}
-    }
-
-  hide();
-  }
-
-/**********************/

Deleted: trunk/src/firsttime.h
===================================================================
--- trunk/src/firsttime.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/firsttime.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,40 +0,0 @@
-/* Darimasen - firsttime.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-#ifndef FIRSTTIME_H
-#define FIRSTTIME_H
-
-#include "main.h"
-
-/**********************/
-
-class firsttime : public Gtk::Dialog{  
-
-public:
-        
-  firsttime();
-
-private:
-
-  Gtk::Button * okbutton1;
-  Gtk::Image * image1;
-  Gtk::Label * label1;
-  Gtk::HBox * hbox1;
-  Gtk::Label * textlabel;
-  Gtk::Label * imagelabel;
-  Gtk::Label * videolabel;
-  Gtk::Label * musiclabel;
-  Gtk::Entry * textentry;
-  Gtk::Entry * imageentry;
-  Gtk::Entry * videoentry;
-  Gtk::Entry * musicentry;
-  Gtk::Table * table1;
-  Gtk::HBox * hbox2;
-  Gtk::VBox * vbox1;
-
-  void confirm();
-  };
-
-
-/**********************/
-
-#endif //FIRSTTIME_H

Deleted: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/iconmodes.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,1082 +0,0 @@
-/* Darimasen - iconmodes.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "iconmodes.h"
-
-/**********************/
-
-DaIconModes::DaIconModes(guint pos, Darimasen& myParent) {
-
-  parent = &myParent;
-  position = pos; //where we are in the world
-  mode = parent->get_mode();
-
-  lastclick = 0;  // a double-click detector. 
-  filesAtPath = 0; // count files in directory
-
-  try{  //count up the files in the directory. 
-    Gnome::Vfs::DirectoryHandle handle;
-    handle.open(parent->get_history(position), Gnome::Vfs::FILE_INFO_DEFAULT);
-    bool file_exists = true;
-    while(file_exists){
-      handle.read_next(file_exists);
-      filesAtPath++;
-      }
-    }
-  catch(const Gnome::Vfs::exception&){}
-
-  set_visible_window(false);
-
-  iconlist = new proto_icon*[filesAtPath];
-  slotsUsed = 0;
-  IconsHigh = 0;
-  try { // make all those files into proto_icons
-    Gnome::Vfs::DirectoryHandle::visit(
-      parent->get_history(position),
-      Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
-      Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
-      Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
-      sigc::mem_fun(*this,&DaIconModes::addEntry));
-    }
-  catch(const Gnome::Vfs::exception& ex){}
-  }
-
-/**********************/
-
-DaIconModes::~DaIconModes(){
-  while( slotsUsed > 0)
-    delete iconlist[--slotsUsed];
-  }
-
-/**********************/
-
-DaIconModes::proto_icon::proto_icon(
-      DaIconModes& getParent,
-      Glib::ustring getPath,
-      const Glib::RefPtr<const Gnome::Vfs::FileInfo> getFile) {
-
-  path = getPath;
-  parent = &getParent;
-
-  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create( getPath + ".DirIcon");
-  if (x->uri_exists() && Glib::str_has_suffix(getPath,getFile->get_name() + slash)){
-    icon = Gdk::Pixbuf::create_from_file(getPath + ".DirIcon");
-    FileMime = "AppDir";
-    }
-  else {
-    icon = parent->parent->get_icon(getFile->get_mime_type());
-    FileMime = getFile->get_mime_type();
-    }
-
-  FileName = getFile->get_name();
-
-  if (getFile->get_name().length() > 25){
-    int last = getFile->get_name().rfind(".");
-    if (last != -1){
-      ShortFileName = getFile->get_name().substr(0, 20) + ".." + getFile->get_name().substr(last);
-      }
-    else {
-      ShortFileName = getFile->get_name().substr(0,22) + "...";
-      }
-    }
-  else {
-    ShortFileName = getFile->get_name();
-    }
-
-  guint size = getFile->get_size();
-  if(size < 1024)
-    FileSize = int2ustr(size) + " B";
-  else if (size < 1048576)
-    FileSize = int2ustr(size / 1024) + " KB";
-  else
-    FileSize = int2ustr(size / 1048576) + " MB";
-
-  hidden = (getFile->get_name().substr(0,1) == ".");
-  };
-
-/**********************/
-
-DaIconModes::proto_icon::~proto_icon(){
-  icon.clear();
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::copy() {
-  CopyDialogue * cp =  new CopyDialogue( path + FileName , *parent->parent);
-  cp->show();
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::link() {
-  LinkDialogue * ln =  new LinkDialogue( path + FileName , *parent->parent);
-  ln->show();
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::move() {
-  MoveDialogue * mv =  new MoveDialogue( path + FileName , *parent->parent);
-  mv->show();
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::run() const{
-
-  Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(path + FileName);
-
-  if (!x->uri_exists()){
-    std::cout << "Is not a file - ";
-    x = Gnome::Vfs::Uri::create(path);
-    if (!x->uri_exists()){
-      std::cout << "is not an appdir either. Bogus.\n";
-      }
-    else {
-      std::cout << "it is a appdir.\n";
-    Glib::spawn_command_line_async(path + "AppRun");
-
-    parent->parent->set_message(path + " was executed.");
-	return;
-      }
-    }
-
-  Gnome::Vfs::Handle exec_handle;
-
-//check the choices dir
-Glib::ustring choicesdir = get_choices_dir();
-Glib::ustring exec = Glib::get_home_dir();
-  try{
-    exec += choicesdir;
-    exec += "/MIME-types/";
-    Glib::ustring tmp = FileMime;
-    exec += tmp.replace(tmp.find("/"),1,"_");
-    exec_handle.open(exec, Gnome::Vfs::OPEN_READ);
-
-    exec += " \""  + path + FileName + "\"";
-    exec_command(exec,path);
-
-    parent->parent->set_message(FileName + " was run as " + FileMime);
-    return;
-
-    }
-  catch(const Gnome::Vfs::exception& ex){
-    }
-
-
-  try{
-    exec = exec.substr(0, exec.rfind("_"));
-    exec_handle.open(exec, Gnome::Vfs::OPEN_READ);
-    exec += " \""  + path + FileName + "\"";
-    exec_command(exec,path);
-
-    parent->parent->set_message(FileName + " was run as " + FileMime.substr(0,FileMime.find("/")));
-    return;
-    }
-  catch(const Gnome::Vfs::exception& ex){
-    }
-
-  try{
-    if (Gnome::Vfs::Mime::can_be_executable(FileMime)){
-      parent->parent->set_message( "Running " + path + FileName);
-      exec_command(exec,path);
-      return;
-      }
-   }
-      catch(const Glib::Error) {}
-
-  Gtk::MessageDialog dialog(
-    "This mimetype does not have any action associated with it.\n"
-    "should it be opened as text?",
-    false, Gtk::MESSAGE_ERROR, Gtk::BUTTONS_OK_CANCEL);
-
-
-  //Handle the response:
-  switch(dialog.run()) {
-    case(Gtk::RESPONSE_OK):
-      {
-        Glib::ustring exec = Glib::get_home_dir();
-	exec += choicesdir;
-        exec += "/MIME-types/text";
-        exec += " \""  + path + FileName + "\"";
-        Glib::spawn_command_line_async(exec);
-        parent->parent->set_message(FileName + " was run as a text file.");
-        return;
-        }
-      break;
-    default:
-      parent->parent->set_message("Well, that was useful.");
-      break;
-    }
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::runAsText() const{
-
-  // double checking the file exists
-  Glib::RefPtr<const Gnome::Vfs::FileInfo> info;
-  Gnome::Vfs::Handle read_handle;
-  try{
-    read_handle.open( path + FileName, Gnome::Vfs::OPEN_READ);
-    info = read_handle.get_file_info(
-      Gnome::Vfs::FILE_INFO_GET_MIME_TYPE );
-    }
-  catch(const Gnome::Vfs::exception& ex){
-    std::cout << "Does not exist.\n";
-    return;
-    }
-
-  Glib::ustring choicesdir = get_choices_dir();
-  Gnome::Vfs::Handle exec_handle;
-  Glib::ustring exec = Glib::get_home_dir();
-  try{
-    exec += choicesdir;
-    exec += "/MIME-types/text";
-    exec_handle.open(exec, Gnome::Vfs::OPEN_READ);
-    exec += " \""  + path + FileName + "\"";
-    Glib::spawn_command_line_async(exec);
-
-    parent->parent->set_message(exec + " was run as text");
-    return;
-    }
-  catch(const Gnome::Vfs::exception& ex){}
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::setRunAction() const{
-
-  Gnome::Vfs::Handle read_handle;
-  Glib::RefPtr<const Gnome::Vfs::FileInfo> info;
-  Glib::ustring exec_subtype;
-  Glib::ustring exec_mimetype;
-
-  try {
-    read_handle.open( path + FileName, Gnome::Vfs::OPEN_READ);
-    info = read_handle.get_file_info(
-        Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
-        Gnome::Vfs::FILE_INFO_FORCE_SLOW_MIME_TYPE );
-
-    exec_subtype  = info->get_mime_type();
-    exec_subtype  = exec_subtype.replace( exec_subtype.find("/"), 1, "_" );
-    exec_mimetype = exec_subtype.substr( 0, exec_subtype.rfind("_") );
-
-    ChooseActionDialogue * chooseAction;
-    chooseAction = new ChooseActionDialogue(exec_subtype);
-    chooseAction->show();
-    }
-  catch(const Gnome::Vfs::exception& ex) {
-    parent->parent->set_message("Err... Setting error?");
-    }
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::setPermissions() const{
-
-
-  Gnome::Vfs::Handle read_handle;
-  Glib::RefPtr<Gnome::Vfs::FileInfo> info;
-
-  try {
-    read_handle.open( path + FileName, Gnome::Vfs::OPEN_READ);
-    info = read_handle.get_file_info(Gnome::Vfs::FILE_INFO_GET_ACCESS_RIGHTS);
-
-    setPermissionsDialogue * setPermissions;
-    setPermissions = new setPermissionsDialogue(info,path);
-    setPermissions->show();
-    }
-  catch(const Gnome::Vfs::exception& ex) {
-    parent->parent->set_message("Err... Setting error?");
-    }
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::unlinkify() {
-  DeleteDialogue * del =  new DeleteDialogue( path + FileName , *parent->parent);
-  del->show();
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::press_select(GdkEventButton* event){
-  if ((event->type == GDK_BUTTON_PRESS) && (event->button == 3)){
-
-    for( int i=10; i > 0; i--)
-      parent->prompt.items().pop_back();
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Open \"" + FileName + "\"",
-        sigc::mem_fun(*this,&DaIconModes::proto_icon::run)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Open as text ",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::runAsText)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::SeparatorElem());
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Set Run Action...",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::setRunAction)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Permissions...",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::setPermissions)));
-
-
-    parent->prompt.items().push_back( Gtk::Menu_Helpers::SeparatorElem());
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Copy To...",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::copy)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Move To...",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::move)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Link To...",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::link)));
-
-    parent->prompt.items().push_back(
-      Gtk::Menu_Helpers::MenuElem("Delete ",
-        sigc::mem_fun(*this, &DaIconModes::proto_icon::unlinkify)));
-
-    if (FileMime != "AppDir"){
-      parent->prompt.popup(event->button, event->time);
-      }
-    }
-  }
-
-/**********************/
-
-void DaIconModes::proto_icon::release_select(GdkEventButton* event){
-
-  if ((event->type == GDK_BUTTON_RELEASE) && (event->button == 1)  && (parent->lastclick < event->time)){
-    parent->lastclick = event->time + 1000;
-    run();
-    }
-  }
-
-/**********************/
-
-DaIconModes::Sidecon::Sidecon(proto_icon & in){
-
-  Arrange = new Gtk::Table();
-  source = &in;
-
-  Icon = new Gtk::Image(source->icon->scale_simple(48,48,Gdk::INTERP_TILES));
-  Arrange->attach(*Icon, 0, 1, 0, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-
-  ShortName = new Gtk::Label(" " + source->ShortFileName);
-  ShortName->set_alignment(0,0.5);
-  Arrange->attach(*ShortName, 1, 2, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
-
-  Mime = new Gtk::Label(" " + source->FileMime);
-  Mime->set_alignment(0,0.5);
-  Arrange->attach(*Mime, 1, 2, 1, 2, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
-
-  Size = new Gtk::Label(" " + source->FileSize);
-  Size->set_alignment(0,0.5);
-  Arrange->attach(*Size, 1, 2, 2, 3, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
-
-  add(*Arrange);
-  show_all_children();
-
-  signal_button_press_event().connect_notify(
-    sigc::mem_fun(*source, &DaIconModes::proto_icon::press_select));
-  signal_button_release_event().connect_notify(
-    sigc::mem_fun(*source, &DaIconModes::proto_icon::release_select));
-
-  }
-
-/**********************/
-
-DaIconModes::Sidecon::~Sidecon(){
-  }
-
-/**********************/
-
-DaIconModes::Listview::Listview(proto_icon & in){
-
-  source = &in;
-  Arrange = new Gtk::Table();
-
-  Icon = new Gtk::Image(source->icon->scale_simple(16,16,Gdk::INTERP_TILES));
-  Arrange->attach(*Icon, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
-
-  Name = new Gtk::Label(" " + source->ShortFileName);
-  Name->set_alignment(0,0.5);
-  Arrange->attach(*Name, 1, 2, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
-
-  add(*Arrange);
-  show_all_children();
-
-  signal_button_press_event().connect_notify(
-    sigc::mem_fun(*source, &DaIconModes::proto_icon::press_select));
-  signal_button_release_event().connect_notify(
-    sigc::mem_fun(*source, &DaIconModes::proto_icon::release_select));
-  }
-
-/**********************/
-
-DaIconModes::Listview::~Listview(){
-  }
-
-/**********************/
-
-DaIconModes::ChooseActionDialogue::ChooseActionDialogue(Glib::ustring mimeType){
-
-  mime = mimeType;
-  cancelbutton1 = new class Gtk::Button(Gtk::StockID("gtk-close"));
-  okbutton1 = new class Gtk::Button(Gtk::StockID("gtk-apply"));
-  label1 = new class Gtk::Label("Enter a Shell command:");
-  entry1 = new class Gtk::Entry();
-  vbox1  = new class Gtk::VBox(false, 0);
-
-
-  radiobutton1 = new class Gtk::RadioButton(_RadioBGroup_radiobutton1, 
-    "Set Action For \"" + mimeType.substr(0, mimeType.find("_")) + "\"" );
-
-  radiobutton1->signal_clicked().connect(
-      sigc::bind<Glib::ustring >( sigc::mem_fun(*this,
-      &DaIconModes::ChooseActionDialogue::getCurrentAction), mimeType.substr(0, mimeType.find("_")) ));
-
-  radiobutton2 = new class Gtk::RadioButton(_RadioBGroup_radiobutton1,
-      "Set Action For \"" + mimeType + "\"")  ;
-
-  radiobutton2->signal_clicked().connect(
-      sigc::bind<Glib::ustring >( sigc::mem_fun(*this,
-      &DaIconModes::ChooseActionDialogue::getCurrentAction), mimeType ));
-
-  cancelbutton1->set_flags(Gtk::CAN_FOCUS);
-  cancelbutton1->set_flags(Gtk::CAN_DEFAULT);
-  cancelbutton1->signal_clicked().connect(
-      sigc::mem_fun(*this, &DaIconModes::ChooseActionDialogue::cancled) );
-  okbutton1->set_flags(Gtk::CAN_FOCUS);
-  okbutton1->set_flags(Gtk::CAN_DEFAULT);
-  okbutton1->signal_clicked().connect(
-      sigc::mem_fun(*this, &DaIconModes::ChooseActionDialogue::modifyAction) );
-  get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  radiobutton1->set_flags(Gtk::CAN_FOCUS);
-  radiobutton1->set_mode(true);
-  radiobutton1->set_active(false);
-  radiobutton2->set_flags(Gtk::CAN_FOCUS);
-  radiobutton2->set_mode(true);
-  radiobutton2->set_active(true);
-  label1->set_padding(2,4);
-  label1->set_justify(Gtk::JUSTIFY_LEFT);
-  entry1->set_flags(Gtk::CAN_FOCUS);
-  entry1->set_has_frame(true);
-  vbox1->pack_start(*radiobutton1, Gtk::PACK_SHRINK, 0);
-  vbox1->pack_start(*radiobutton2, Gtk::PACK_SHRINK, 0);
-  vbox1->pack_start(*label1, Gtk::PACK_SHRINK, 0);
-  vbox1->pack_start(*entry1, Gtk::PACK_SHRINK, 0);
-  get_vbox()->set_homogeneous(false);
-  get_vbox()->set_spacing(5);
-  get_vbox()->set_border_width(6);
-  get_vbox()->pack_start(*vbox1);
-  set_border_width(6);
-  set_title("Set Run Action");
-  set_modal(true);
-  property_window_position().set_value(Gtk::WIN_POS_CENTER_ON_PARENT);
-  set_resizable(true);
-  property_destroy_with_parent().set_value(false);
-  set_has_separator(false);
-  add_action_widget(*cancelbutton1, Gtk::RESPONSE_CANCEL);
-  add_action_widget(*okbutton1, Gtk::RESPONSE_OK);
-  set_default_response(Gtk::RESPONSE_OK);
-
-  show_all_children();
-  }
-
-/**********************/
-
-DaIconModes::ChooseActionDialogue::~ChooseActionDialogue(){
-  delete cancelbutton1;
-  delete okbutton1;
-  delete label1;
-  delete entry1;
-  delete vbox1;
-  delete radiobutton1;
-  delete radiobutton2;
-  }
-
-/**********************/
-
-void DaIconModes::ChooseActionDialogue::cancled(){
-  hide();
-  return;
-  }
-
-/**********************/
-
-void DaIconModes::ChooseActionDialogue::getCurrentAction(Glib::ustring mimeType){
-  Glib::ustring contents, exec1 = Glib::get_home_dir();
-  exec1 += get_choices_dir();
-  exec1 += (Glib::ustring)("/MIME-types/");
-  exec1 += mimeType;
-
-  try {
-    contents = Glib::file_get_contents(exec1);
-    contents = contents.substr(contents.find("exec ") + 5);
-    contents = contents.substr(0,contents.find("\n"));
-    }
-  catch(const Glib::Error) {
-    contents = "* \"$@\"" ;
-    }
-  entry1->set_text(contents);
-  }
-
-/**********************/
-
-void DaIconModes::ChooseActionDialogue::modifyAction(){
-
-  if ( entry1->get_text() != "* \"$@\""){ //don't intentionally make a broken script.
-    Glib::ustring command = "#! /bin/sh\nexec ";
-    command += entry1->get_text();
-    command += "\n";
-
-    try {
-      Glib::ustring exec1 = Glib::get_home_dir();
-      Glib::ustring choicesdir = get_choices_dir();
-      exec1 += choicesdir;
-      exec1 += (Glib::ustring)("/MIME-types/");
-      if(radiobutton2->get_active()) exec1 += mime;
-      if(radiobutton1->get_active())exec1 += mime.substr(0, mime.find("_"));
-      Gnome::Vfs::Handle write_handle;
-
-      // Now write the data we read out to the output uri
-      write_handle.create(exec1, Gnome::Vfs::OPEN_WRITE, false, 0755);
-      write_handle.seek(Gnome::Vfs::SEEK_POS_START, 0);
-      GnomeVFSFileSize bytes_written = write_handle.write(command.data(), command.size());
-      }
-    catch(const Gnome::Vfs::exception) {
-      //  parent->set_message("Couldn't write new definition.");
-      hide();
-      return;
-      }
-    }
-  hide();
-  return;
-  }
-
-/**********************/
-
-DaIconModes::setPermissionsDialogue::setPermissionsDialogue(Glib::RefPtr<Gnome::Vfs::FileInfo> info,
-                                                            Glib::ustring path){
-  fullPath = path;
-  set_title("Set file permissions");
-  set_modal(true);
-
-   read = new class Gtk::Label("R");
-   write = new class Gtk::Label("W");
-   run = new class Gtk::Label("X");
-   user = new class Gtk::Label("User");
-   group = new class Gtk::Label("Group");
-   others = new class Gtk::Label("Everybody");
-
-   user->set_alignment(0.96,0.5);
-   group->set_alignment(0.96,0.5);
-
-   explaination = new class Gtk::Label("for \""+ info->get_name() + "\"...");
-
-   layout = new class Gtk::Table(5, 6, false);
-
-   u_r = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_USER_READ) != 0)  u_r->set_active(true);
-   u_w = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_USER_WRITE) != 0)  u_w->set_active(true);
-   u_x = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_USER_EXEC) != 0)  u_x->set_active(true);
-   g_r = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_GROUP_READ) != 0)  g_r->set_active(true);
-   g_w = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_GROUP_WRITE) != 0)  g_w->set_active(true);
-   g_x = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_GROUP_EXEC) != 0)  g_x->set_active(true);
-   o_r = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_OTHER_READ) != 0)  o_r->set_active(true);
-   o_w = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_OTHER_WRITE) != 0)  o_w->set_active(true);
-   o_x = new class Gtk::CheckButton("");
-   if((info->get_permissions() & Gnome::Vfs::PERM_OTHER_EXEC) != 0)  o_x->set_active(true);
-
-   extra = new  Gtk::VSeparator;
-
-   sticky = new class Gtk::CheckButton("Sticky");
-   if((info->get_permissions() & Gnome::Vfs::PERM_STICKY) != 0)  sticky->set_active(true);
-   GID = new class Gtk::CheckButton("Group ID");
-   if((info->get_permissions() & Gnome::Vfs::PERM_SGID) != 0)  GID->set_active(true);
-   UID = new class Gtk::CheckButton("User ID");
-   if((info->get_permissions() & Gnome::Vfs::PERM_SUID) != 0)  UID->set_active(true);
-
-   layout->attach(*u_r, 1, 2, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*u_w, 2, 3, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*u_x, 3, 4, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*g_r, 1, 2, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*g_w, 2, 3, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*g_x, 3, 4, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*o_r, 1, 2, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*o_w, 2, 3, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*o_x, 3, 4, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
-
-   layout->attach(*extra,4,5,1,5, Gtk::FILL | Gtk::EXPAND, Gtk::FILL, 10, 0);
-
-   layout->attach(*sticky, 5, 6, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*GID, 5, 6, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*UID, 5, 6, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
-
-   layout->attach(*read, 1, 2, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*write, 2, 3, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*run, 3, 4, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   layout->attach(*user, 0, 1, 2, 3, Gtk::FILL , Gtk::FILL, 0, 0);
-   layout->attach(*group, 0, 1, 3, 4, Gtk::FILL , Gtk::FILL, 0, 0);
-   layout->attach(*others, 0, 1, 4, 5, Gtk::FILL , Gtk::FILL, 0, 0);
-   layout->attach(*explaination, 0, 6, 0, 1, Gtk::FILL | Gtk::EXPAND, Gtk::FILL, 10, 0);
-
-
-  get_vbox()->pack_start(*layout);
-  button1 = new class Gtk::Button(Gtk::StockID("gtk-cancel"));
-  button1->signal_clicked().connect(
-      sigc::mem_fun(*this, &DaIconModes::setPermissionsDialogue::cancled) );
-
-
-  button2 = new class Gtk::Button(Gtk::StockID("gtk-apply"));
-  button2->signal_clicked().connect(
-    sigc::bind<Glib::RefPtr<Gnome::Vfs::FileInfo> >(
-      sigc::mem_fun(*this, &DaIconModes::setPermissionsDialogue::apply), info ));
-
-
-  get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
-  add_action_widget(*button1, -6);
-  add_action_widget(*button2, -10);
-
-  set_modal(true);
-  show_all_children();
-  show();
-  }
-
-/**********************/
-
-DaIconModes::setPermissionsDialogue::~setPermissionsDialogue(){
-      delete read, write, run;
-      delete user, group, others;
-      delete explaination;
-      delete layout;
-      delete u_r, u_w, u_x, g_r, g_w, g_x, o_r, o_w, o_x;
-      delete extra;
-      delete sticky;
-      delete GID;
-      delete UID;
-      delete button1, button2;
-      }
-
-/**********************/
-
-void DaIconModes::setPermissionsDialogue::cancled(){
-  hide();
-  }
-
-/**********************/
-
-void DaIconModes::setPermissionsDialogue::apply(Glib::RefPtr<Gnome::Vfs::FileInfo> info){
-
-  // *nix and *BSD only, blah blah blah.
-  int permissions = 0;
-
-  if(UID->get_active()) permissions += 2048;
-  if(GID->get_active()) permissions += 1024;
-  if(sticky->get_active()) permissions += 512;
-
-  if(u_r->get_active()) permissions += 256;
-  if(u_w->get_active()) permissions += 128;
-  if(u_x->get_active()) permissions += 64;
-
-  if(g_r->get_active()) permissions += 32;
-  if(g_w->get_active()) permissions += 16;
-  if(g_x->get_active()) permissions += 8;
-
-  if(o_r->get_active()) permissions += 4;
-  if(o_w->get_active()) permissions += 2;
-  if(o_x->get_active()) permissions += 1;
-
-  chmod((fullPath + info->get_name()).c_str(), permissions);
-
-  hide();
-  }
-
-/**********************/
-
-DaIconModes::CopyDialogue::CopyDialogue(Glib::ustring file, Darimasen& parent){
-
-grandparent = &parent;
-   cancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-   okbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   label = Gtk::manage(new class Gtk::Label(file));
-   entry = Gtk::manage(new class Gtk::Entry());
-
-   okbutton->set_flags(Gtk::CAN_FOCUS);
-   okbutton->set_flags(Gtk::CAN_DEFAULT);
-   cancelbutton->set_flags(Gtk::CAN_FOCUS);
-
-   set_title("Copy File to");
-   set_modal(true);
-
-   get_vbox()->pack_start(*label, Gtk::PACK_SHRINK, 0);
-   get_vbox()->pack_start(*entry, Gtk::PACK_SHRINK, 0);
-
-
-   entry->set_text(file);
-
-   add_action_widget(*cancelbutton, -6);
-   add_action_widget(*okbutton, -5);
-
-
-   okbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::CopyDialogue::onOk));
-   cancelbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::CopyDialogue::onCancel));
-
-
-   show_all_children();
-  }
-
-/**********************/
-
-DaIconModes::CopyDialogue::~CopyDialogue(){}
-
-/**********************/
-
-void DaIconModes::CopyDialogue::onCancel(){
-  hide();
-  }
-
-/**********************/
-
-void DaIconModes::CopyDialogue::onOk(){
-  Glib::spawn_command_line_async((Glib::ustring)"cp \""  + label->get_text().c_str() + (Glib::ustring)"\" \"" + entry->get_text().c_str()+ "\"");
-
-  grandparent->updateView(
-    label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
-    entry->get_text().substr(0, entry->get_text().rfind(slash,entry->get_text().length())+1));
-
-  hide();
-  }
-
-/**********************/
-
-DaIconModes::LinkDialogue::LinkDialogue(Glib::ustring file, Darimasen& parent){
-
-grandparent = &parent;
-   cancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-   okbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   label = Gtk::manage(new class Gtk::Label(file));
-   entry = Gtk::manage(new class Gtk::Entry());
-
-   okbutton->set_flags(Gtk::CAN_FOCUS);
-   okbutton->set_flags(Gtk::CAN_DEFAULT);
-   cancelbutton->set_flags(Gtk::CAN_FOCUS);
-
-   set_title("Link File to");
-   set_modal(true);
-
-   get_vbox()->pack_start(*label, Gtk::PACK_SHRINK, 0);
-   get_vbox()->pack_start(*entry, Gtk::PACK_SHRINK, 0);
-
-
-   entry->set_text(file);
-
-   add_action_widget(*cancelbutton, -6);
-   add_action_widget(*okbutton, -5);
-
-
-   okbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::LinkDialogue::onOk));
-   cancelbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::LinkDialogue::onCancel));
-
-
-   show_all_children();
-  }
-
-/**********************/
-
-DaIconModes::LinkDialogue::~LinkDialogue(){}
-
-/**********************/
-
-void DaIconModes::LinkDialogue::onCancel(){
-  hide();
-  }
-
-/**********************/
-
-void DaIconModes::LinkDialogue::onOk(){
-  Glib::spawn_command_line_async((Glib::ustring)"ln -s \""  + label->get_text().c_str() + (Glib::ustring)"\" \"" + entry->get_text().c_str() + "\"");
-
-  grandparent->updateView(
-    label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
-    entry->get_text().substr(0, entry->get_text().rfind(slash,entry->get_text().length())+1));
-
-  hide();
-  }
-
-/**********************/
-
-DaIconModes::MoveDialogue::MoveDialogue(Glib::ustring file, Darimasen& parent){
-
-grandparent = &parent;
-   cancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-   okbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   label = Gtk::manage(new class Gtk::Label(file));
-   entry = Gtk::manage(new class Gtk::Entry());
-
-   okbutton->set_flags(Gtk::CAN_FOCUS);
-   okbutton->set_flags(Gtk::CAN_DEFAULT);
-   cancelbutton->set_flags(Gtk::CAN_FOCUS);
-
-   set_title("Move File to");
-   set_modal(true);
-
-   get_vbox()->pack_start(*label, Gtk::PACK_SHRINK, 0);
-   get_vbox()->pack_start(*entry, Gtk::PACK_SHRINK, 0);
-
-
-   entry->set_text(file);
-
-   add_action_widget(*cancelbutton, -6);
-   add_action_widget(*okbutton, -5);
-
-
-   okbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::MoveDialogue::onOk));
-   cancelbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::MoveDialogue::onCancel));
-
-
-   show_all_children();
-  }
-
-/**********************/
-
-DaIconModes::MoveDialogue::~MoveDialogue(){}
-
-/**********************/
-
-void DaIconModes::MoveDialogue::onCancel(){
-  hide();
-  }
-
-/**********************/
-
-void DaIconModes::MoveDialogue::onOk(){
-  Glib::spawn_command_line_async((Glib::ustring)"mv \""  + label->get_text().c_str() + (Glib::ustring)"\" \"" + entry->get_text().c_str()+ "\"");
-/*
-  try
-  {
-    Gnome::Vfs::Transfer::transfer(label->get_text().c_str(), entry->get_text().c_str());  
-  }
-  catch(const Gnome::Vfs::exception& ex)
-  {
-    // if the operation was not successful, print the error
-    std::cout << "Error occurred: " << label->get_text() << ", " << ex.what() << std::endl;
-  }*/
-
-  grandparent->updateView(
-    label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
-    entry->get_text().substr(0, entry->get_text().rfind(slash,entry->get_text().length())+1));
-
-  hide();
-  }
-
-/**********************/
-
-DaIconModes::DeleteDialogue::DeleteDialogue(Glib::ustring file, Darimasen& parent){
-
-grandparent = &parent;
-   cancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
-   okbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
-   label = Gtk::manage(new class Gtk::Label(file));
-
-   okbutton->set_flags(Gtk::CAN_FOCUS);
-   okbutton->set_flags(Gtk::CAN_DEFAULT);
-   cancelbutton->set_flags(Gtk::CAN_FOCUS);
-
-   set_title("Delete File");
-   set_modal(true);
-
-   get_vbox()->pack_start(*label, Gtk::PACK_SHRINK, 0);
-
-   add_action_widget(*cancelbutton, -6);
-   add_action_widget(*okbutton, -5);
-
-
-   okbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::DeleteDialogue::onOk));
-   cancelbutton->signal_clicked().connect_notify(sigc::mem_fun(*this, &DaIconModes::DeleteDialogue::onCancel));
-
-
-   show_all_children();
-  }
-
-/**********************/
-
-DaIconModes::DeleteDialogue::~DeleteDialogue(){}
-
-/**********************/
-
-void DaIconModes::DeleteDialogue::onCancel(){
-  hide();
-  }
-
-/**********************/
-
-void DaIconModes::DeleteDialogue::onOk(){
-  Glib::spawn_command_line_async((Glib::ustring)"rm \""  + label->get_text().c_str() + "\"");
-
-/*  try
-  {
-    Gnome::Vfs::Transfer::remove(label->get_text().c_str());  
-  }
-  catch(const Gnome::Vfs::exception& ex)
-  {
-    // if the operation was not successful, print the error
-    std::cout << "Error occurred: " << label->get_text() << ", " << ex.what() << std::endl;
-  }*/
-
-  grandparent->updateView(
-    label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1),
-    label->get_text().substr(0, label->get_text().rfind(slash,label->get_text().length())+1));
-  hide();
-  }
-
-/**********************/
-
-bool DaIconModes::addEntry(
-    Glib::ustring rel_path,
-    Glib::RefPtr<const Gnome::Vfs::FileInfo> info,
-    bool recursing_will_loop,
-    bool recurse) {
-
-  if (info->get_type() != Gnome::Vfs::FILE_TYPE_DIRECTORY){
-    iconlist[slotsUsed++] = new proto_icon(*this, parent->get_history(position), info);
-    }
-  else {
-    Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
-      parent->get_history(position) + info->get_name() + slash + ".DirIcon");
-      if (x->uri_exists()){
-        iconlist[slotsUsed++] = new proto_icon(
-          *this, parent->get_history(position) + info->get_name() + slash, info);
-        }
-    }
-
-  return true;
-  }
-
-/**********************
-
-bool on_transfer_progress(const Gnome::Vfs::Transfer::ProgressInfo& info){
-//if (info->get_vfs_status() == Gnome::Vfs::OK)
-//  parent->set_message("OK!");
-
-
-    }
-
-/**********************/
-
-void DaIconModes::on_size_allocate(Gtk::Allocation& allocation){
-
-  int oldie = IconsHigh;
-
-  switch(mode){
-    case 0:
-      IconsHigh = allocation.get_height() / 57;
-      break;
-    case 1:
-      IconsHigh = allocation.get_height() / 25;
-      break;
-    }
-  if ( oldie != IconsHigh ){ //if resize is needed
-    Gtk::Widget * tmp = get_child();
-    redraw();
-    }
-
-  Gtk::EventBox::on_size_allocate(allocation);
-  }
-
-/**********************/
-
-void DaIconModes::redraw(){
-  Gtk::Widget * tmp = get_child();
-  
-  if (tmp)
-    delete tmp; // actually DisposableTable, but segfaulted otherwise
-
-  Gtk::Table * DisposableTable = new Gtk::Table((slotsUsed)/IconsHigh+1,IconsHigh);
-  add(*DisposableTable);
-
-  int y_pos = 0;
-  int x_pos = 0;
-
-  for(int i = 0; i < slotsUsed; i++){
-    if(  !iconlist[i]->hidden || parent->get_hidden()){
-      switch(mode){
-        case 0: {
-          Sidecon * tmpSidecon = new Sidecon(*iconlist[i]);
-          Gtk::Alignment * alignment1 = Gtk::manage(
-            new class Gtk::Alignment(Gtk::ALIGN_LEFT, Gtk::ALIGN_CENTER, 0, 0));
-          alignment1->add(*tmpSidecon);
-          DisposableTable->attach( *alignment1, x_pos, x_pos+1, y_pos, y_pos+1,
-            Gtk::FILL, Gtk::FILL , 4, 4);
-            }
-          break;
-        case 1: {
-          Listview * tmpListview = new Listview(*iconlist[i]);
-          Gtk::Alignment * alignment1 = Gtk::manage(
-            new class Gtk::Alignment(Gtk::ALIGN_LEFT, Gtk::ALIGN_CENTER, 0, 0));
-          alignment1->add(*tmpListview);
-          DisposableTable->attach( *alignment1, x_pos, x_pos+1, y_pos, y_pos+1,
-            Gtk::FILL, Gtk::FILL, 4, 4);
-            }
-          break;
-        }
-
-      y_pos++; 
-      if(parent->get_mode() == 0 || parent->get_mode() == 1){
-        if ( y_pos + 1 > IconsHigh){
-          y_pos = 0;
-          x_pos++;
-          }
-        }
-      }
-    }
-  DisposableTable->show();
-  DisposableTable->show_all_children();
-  }
-
-/**********************/
-
-guint DaIconModes::get_position(){
-  return position;
-  }
-
-/**********************/
-
-void DaIconModes::SwitchHidden(guint pos){
-
-  position = pos;
-  if (parent->get_hidden())
-    parent->set_message("Showing Hidden Files");
-  else
-    parent->set_message("Hidden Files are hidden again");
-
-  redraw();
-  }
-
-/**********************/
-
-void DaIconModes::update_position(guint pos){
-  position = pos;
-  }
-
-/**********************/
-

Deleted: trunk/src/iconmodes.h
===================================================================
--- trunk/src/iconmodes.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/iconmodes.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,252 +0,0 @@
-/* Darimasen - iconmodes.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-#ifndef ICONMODES_H
-#define ICONMODES_H
-
-
-#include "main.h"
-#include "darimasen.h"
-
-/**********************/
-
-class DaIconModes : public Gtk::EventBox {
-
-public:
-
-  DaIconModes(guint, class Darimasen&);
-  ~DaIconModes();
-
-private:
-
-  /****/
-
-  class proto_icon {
-  public:
-
-    proto_icon(DaIconModes&, Glib::ustring, const Glib::RefPtr<const Gnome::Vfs::FileInfo>);
-    ~proto_icon();
-
-  private:
-
-    Glib::ustring path;
    DaIconModes * parent;
-
-    void copy();
-    void link();
-    void move();
-    void run() const;
-    void runAsText() const;
-    void setRunAction() const;
-    void setPermissions() const;
-    void unlinkify();
-
-  public:
-
-    Glib::RefPtr<Gdk::Pixbuf> icon;
-    Glib::ustring FileName;
-    Glib::ustring ShortFileName;
-    Glib::ustring FileMime;
-    Glib::ustring FileSize;
-
-    bool hidden;
-
-    void press_select(GdkEventButton*);
-    void release_select(GdkEventButton*);
-    };
-
-  /****/
-
-  class Sidecon : public Gtk::EventBox {
-  public:
-
-    Sidecon(proto_icon&);
-    ~Sidecon();
-
-  private:
-    proto_icon * source;
-    Gtk::Table * Arrange;
-    Gtk::Image * Icon;
-    Gtk::Label * ShortName;
-    Gtk::Label * Mime;
-    Gtk::Label * Size;
-  };
-
-  /****/
-
-  class Listview : public Gtk::EventBox {
-  public:
-
-    Listview(proto_icon&);
-    ~Listview();
-
-  private:
-
-    proto_icon * source;
-    Gtk::Table * Arrange;
-    Gtk::Image * Icon;
-    Gtk::Label * Name;
-  };
-
-  /****/
-
-  class ChooseActionDialogue : public Gtk::Dialog {
-  public:
-
-    ChooseActionDialogue(Glib::ustring);
-    ~ChooseActionDialogue();
-
-  private:
-
-    Gtk::RadioButton::Group _RadioBGroup_radiobutton1;
-    Gtk::Button *cancelbutton1, *okbutton1;
-    Gtk::RadioButton *radiobutton1, *radiobutton2;
-    Gtk::Label       * label1;
-    Gtk::Entry       * entry1;
-    Gtk::VBox        * vbox1;
-    Glib::ustring mime;
-    void cancled();
-    void getCurrentAction(Glib::ustring);
-    void modifyAction();
-
-    };
-
-  /****/
-
-  class setPermissionsDialogue : public Gtk::Dialog {
-
-  public:
-
-    setPermissionsDialogue(Glib::RefPtr<Gnome::Vfs::FileInfo> , Glib::ustring);
-    ~setPermissionsDialogue();
-
-  private:
-
-    Glib::ustring fullPath;
-    Gtk::Button * button1;
-    Gtk::Button * button2;
-
-    Gtk::CheckButton * u_r, * u_w, * u_x;
-    Gtk::CheckButton * g_r, * g_w, * g_x;
-    Gtk::CheckButton * o_r, * o_w, * o_x;
-    
-    Gnome::Vfs::Handle info;
-
-    Gtk::VSeparator * extra;
-    Gtk::CheckButton * sticky, * GID, * UID;
-
-    Gtk::Label * user, * group, * others;
-    Gtk::Label * read, * write, * run;
-    Gtk::Label * explaination;
-
-    Gtk::Table * layout;
-
-    void cancled();
-    void apply(Glib::RefPtr<Gnome::Vfs::FileInfo>);
-    };
-
-  /****/
-
-  class CopyDialogue : public Gtk::Dialog {
-
-  public:
-
-    CopyDialogue(Glib::ustring, Darimasen&);
-    ~CopyDialogue();
-
-  private:
-
-    class Darimasen * grandparent;
-
-    class Gtk::Button * cancelbutton;
-    class Gtk::Button * okbutton;
-    class Gtk::Label * label;
-    class Gtk::Entry * entry;
-
-    void onCancel();
-    void onOk();
-    };
-
-  /****/
-
-  class LinkDialogue : public Gtk::Dialog {
-  public:
-
-    LinkDialogue(Glib::ustring, Darimasen&);
-    ~LinkDialogue();
-
-  private:
-
-    class Gtk::Button * cancelbutton;
-    class Gtk::Button * okbutton;
-    class Gtk::Label * label;
-    class Gtk::Entry * entry;
-    void onOk();
-    void onCancel();
-
-    class Darimasen * grandparent;
-
-
-    };
-
-  /****/
-
-  class MoveDialogue : public Gtk::Dialog {
-  public:
-    MoveDialogue(Glib::ustring, Darimasen&);
-    ~MoveDialogue();
-
-  private:
-
-    class Gtk::Button * cancelbutton;
-    class Gtk::Button * okbutton;
-    class Gtk::Label * label;
-    class Gtk::Entry * entry;
-    void onOk();
-    void onCancel();
-    class Darimasen * grandparent;
-    };
-
-  /****/
-
-  class DeleteDialogue : public Gtk::Dialog {
-  public:
-    DeleteDialogue(Glib::ustring, Darimasen&);
-    ~DeleteDialogue();
-
-  private:
-
-    class Gtk::Button * cancelbutton;
-    class Gtk::Button * okbutton;
-    class Gtk::Label * label;
-    void onOk();
-    void onCancel();
-
-    class Darimasen * grandparent;
-    };
-
-  /****/
-
-  bool addEntry(Glib::ustring, Glib::RefPtr<const Gnome::Vfs::FileInfo>, bool, bool);
-  void on_size_allocate(Gtk::Allocation&);
- // bool on_transfer_progress(const Gnome::Vfs::Transfer::ProgressInfo&);
-  void redraw();
-
-  class Darimasen * parent;
-  guint position;
-  guint32 lastclick;
-  guint filesAtPath;
-  gshort mode;
-  proto_icon ** iconlist;
-  guint slotsUsed;
-  guint IconsHigh;
-  Gtk::Menu prompt;
-
-public:
-
-  guint get_position();
-  void SwitchHidden(guint);
-  void update_position(guint);
-};
-
-/**********************/
-
-#endif //ICONMODES_H

Deleted: trunk/src/main.cpp
===================================================================
--- trunk/src/main.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/main.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,89 +0,0 @@
-/* Darimasen - main.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-   
-/**********************/
-  
-#include "main.h"
-
-#include "firsttime.h"
-#include "darimasen.h"
-
-/**********************/
-  
-int main(int argc, char *argv[])
-{
-  Gtk::Main kit(argc, argv);
-  Gnome::Vfs::init();
-
-  //The new get_choices_dir() really speeds this up...
-  //Glib::get_home_dir() + get_choices_dir(); -- will be ~/Choices if exists, ~/.choices otherwise
-  {
-    // make .choices if nothing available
-    if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir())->uri_exists()){
-      gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir()).c_str(),493);
-      }
-
-    // make MIME-types if nothing available, set up basics
-    if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir() + "/MIME-types")->uri_exists()){
-      gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir() + "/MIME-types").c_str(),493);
-      firsttime window; 
-      Gtk::Main::run(window);
-      }
-
-    // make our own settings folder if nothing available
-    if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir() + "/Darimasen")->uri_exists()){
-      gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir() + "/Darimasen").c_str(),493);
-      }
-    }
-
-  std::vector<Glib::ustring> path;
-
-  // parse all the possible paths on the command line
-  for( int i=1; i < argc; i++){
-    if((argv[i][0]!='-') && (argv[i-1][0]!='-')){ // some quick anti-argument logic
-      Glib::ustring tmp = argv[i];
-      if(tmp.substr(tmp.length()-1,1) != slash )
-        tmp += slash;
-       Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(tmp);
-      // case that URL is Absolute, and works:
-      if (x->uri_exists()){
-        path.push_back(x->get_path());
-        }
-      // case that URL is Absolute, but pointing to a file
-      else if (tmp.substr(0,1) == slash){
-        x = x->get_parent();
-        if (x->uri_exists()){
-          path.push_back(x->get_path()+slash);
-          }
-        }
-      // URL can only be relative. 
-      else {
-        x = x->resolve_relative (get_current_dir_name() + slash + tmp);
-        //URL was relative, and works.
-        if (x->uri_exists()){
-          path.push_back(x->get_path());
-          }
-        // URL is relative, but pointing to file
-        else{
-            x = x->get_parent();
-            path.push_back(x->get_path()+slash);
-          }
-        }
-      }
-    }
-
-  if(path.empty())
-    path.push_back(Glib::get_home_dir() + slash);
-
-
-  std::cout << "Tabs opened should be for:\n";
-  for(int i =0; i< path.size();i++)
-      std::cout << path[i] <<  "\n";
-
-  Darimasen window(path);
-  Gtk::Main::run(window); 
-
-  return 0;
-  }
-
-
-/**********************/

Deleted: trunk/src/main.h
===================================================================
--- trunk/src/main.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/main.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,27 +0,0 @@
-/* Darimasen - main.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-#ifndef MAIN_H
-#define MAIN_H
-
-/**********************/
-
-#include <vector>
-#include <iostream>
-#include <libgnomevfsmm.h>
-#include <gtkmm.h>
-
-#include "supplimental.h"
-
-/**********************/
-
-#ifdef WIN32
-const Glib::ustring slash = "\\";
-#else
-const Glib::ustring slash = "/";
-#endif
-
-//const unsigned short AvailableModes = 2;
-
-/**********************/
-
-#endif //MAIN_H

Deleted: trunk/src/optionsManager.cpp
===================================================================
--- trunk/src/optionsManager.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/optionsManager.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,57 +0,0 @@
-/* Darimasen - optionsManager.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "optionsManager.h"
-
-/**********************/
-
-// get the contents out of one of our XML settings files
-optionsQuery::optionsQuery(Glib::ustring toParse){
-
-  DumpParser parser;
-  Glib::Markup::ParseContext context (parser);
-
-  try{
-    context.parse(Glib::file_get_contents(toParse));
-    context.end_parse();
-    }
-  catch(const Glib::Error) {
-    //std::cout<< "Error! Settings file " << toParse << " not found.\n";
-    }
-  }
-
-/**********************/ 
-
-// write out to file
-optionsQuery::~optionsQuery(){
-  }
-
-/**********************/ 
-
-void optionsQuery::DumpParser::on_start_element(Glib::Markup::ParseContext&,
-                                  const Glib::ustring&,
-                                  const AttributeMap&  attributes){
-  for(AttributeMap::const_iterator p = attributes.begin(); p != attributes.end(); ++p){
-    std::cout <<  p->second ;
-    }
-  }
-
-/**********************/
-
-void optionsQuery::DumpParser::on_text(Glib::Markup::ParseContext&, const Glib::ustring& text){
-  Glib::ustring trimmed_text = trim_whitespace(text);
-  if (!trimmed_text.empty()) std::cout << " " << trimmed_text << "\n";
-  }
-
-/**********************/ 
-
-//return set values
-  Glib::ustring optionsQuery::get_option(Glib::ustring){}
-
-/**********************/ 
-
-//set values in out vectors
-  bool optionsQuery::set_option(Glib::ustring, Glib::ustring){}
-
-/**********************/ 

Deleted: trunk/src/optionsManager.h
===================================================================
--- trunk/src/optionsManager.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/optionsManager.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,41 +0,0 @@
-/* Darimasen - optionsManager.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-
-
-#ifndef OPTIONS_H
-#define OPTIONS_H
-
-/**********************/
-
-#include "main.h"
-
-/**********************/
-
-class optionsQuery{
-public:
-
-  optionsQuery(Glib::ustring);
-  ~optionsQuery();
-
-private:
-
-
-  class DumpParser : public Glib::Markup::Parser {
-    void on_start_element(Glib::Markup::ParseContext&, const Glib::ustring&, const AttributeMap&);
-    void on_text(Glib::Markup::ParseContext& context, const Glib::ustring& text);
-    };
-  struct optionholder {
-    Glib::ustring name;
-    Glib::ustring value;
-    };
-  
-  std::vector<optionholder> optionVector;
-public:
-
-  Glib::ustring get_option(Glib::ustring);
-  bool set_option(Glib::ustring, Glib::ustring);
-  };
-
-/**********************/
-
-#endif //SUPPLIMENTAL_H

Deleted: trunk/src/supplimental.cpp
===================================================================
--- trunk/src/supplimental.cpp	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/supplimental.cpp	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,66 +0,0 @@
-/* Darimasen - supplimental.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-/**********************/
-
-#include "supplimental.h"
-/**********************/
-
-Glib::ustring int2ustr(int x){
-  Glib::ustring tmp ="";
-  char tmp2 =' ';
-  
-  do{
-    tmp2 = static_cast<char>((x % 10)+48);
-    tmp = tmp2 + tmp;
-    x = static_cast<int>(x/10.0);
-    }while (x > 0);          
-  return tmp;
-  }
-
-/**********************/
-
-//check which choices dir to use
-Glib::ustring get_choices_dir(){
-  if (Gnome::Vfs::Uri::create(Glib::get_home_dir() + "/Choices")->uri_exists()) return "/Choices";
-  else return "/.choices";
-  }
-
-/**********************/
-
-//execute a command in the correct working directory
-void exec_command(Glib::ustring exec, Glib::ustring path){
-    Glib::spawn_async(path, Glib::shell_parse_argv(exec), Glib::SPAWN_SEARCH_PATH);
-  }
-
-/**********************/
-
-Glib::ustring trim_whitespace(const Glib::ustring& text){
-  Glib::ustring::const_iterator pbegin (text.begin());
-  Glib::ustring::const_iterator pend   (text.end());
-
-  while(pbegin != pend && Glib::Unicode::isspace(*pbegin))
-    ++pbegin;
-
-  Glib::ustring::const_iterator temp (pend);
-
-  while(pbegin != temp && Glib::Unicode::isspace(*--temp))
-    pend = temp;
-
-  return Glib::ustring(pbegin, pend);
-}
-
-/**********************/
-
-Glib::ustring underscore_safe(Glib::ustring x){
-  int startAtPos = 0, found = 0;
-  Glib::ustring tmp = x;
-
-  while (x.find("_",startAtPos) != -1){
-          startAtPos = x.find("_", startAtPos);
-          tmp.replace(startAtPos++ + found++, 1, "__");  
-          }
-   
-  return tmp;
-  }
-
-/**********************/ 

Deleted: trunk/src/supplimental.h
===================================================================
--- trunk/src/supplimental.h	2005-05-23 00:35:14 UTC (rev 76)
+++ trunk/src/supplimental.h	2005-05-23 03:07:19 UTC (rev 77)
@@ -1,25 +0,0 @@
-/* Darimasen - supplimental.h - Copyright (C) 2004 - 2005 Sudrien, GPL */
-
-#ifndef SUPPLIMENTAL_H
-#define SUPPLIMENTAL_H
-
-/**********************/
-
-#include "main.h"
-
-/**********************/
-
-Glib::ustring int2ustr(int);
-
-Glib::ustring get_choices_dir();
-
-void exec_command(Glib::ustring, Glib::ustring);
-
-Glib::ustring trim_whitespace(const Glib::ustring&);
-
-Glib::ustring underscore_safe(Glib::ustring);
-
-/**********************/
-
-#endif //SUPPLIMENTAL_H
-



From darimasen-svn-admin at lists.berlios.de  Wed May 25 04:34:48 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Wed, 25 May 2005 04:34:48 +0200
Subject: [Darimasen-svn] r78 - trunk/src
Message-ID: <200505250234.j4P2YmNY010172@sheep.berlios.de>

Author: sudrien
Date: 2005-05-25 04:34:38 +0200 (Wed, 25 May 2005)
New Revision: 78

Added:
   trunk/src/darimasen.cpp
   trunk/src/darimasen.h
   trunk/src/darimasen.txt
   trunk/src/directory.cpp
   trunk/src/directory.h
   trunk/src/directory.txt
   trunk/src/icon.cpp
   trunk/src/icon.h
   trunk/src/icon.txt
   trunk/src/main.cpp
   trunk/src/main.h
   trunk/src/main.txt
   trunk/src/menu.cpp
   trunk/src/menu.h
   trunk/src/menu.txt
   trunk/src/preferences.cpp
   trunk/src/preferences.h
   trunk/src/preferences.txt
   trunk/src/supplimental.cpp
   trunk/src/supplimental.h
   trunk/src/supplimental.txt
   trunk/src/tabs.cpp
   trunk/src/tabs.h
   trunk/src/tabs.txt
Modified:
   trunk/src/Makefile.am
Log:
gnomevfs-sharp isn't there yet-using C++ for now

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/Makefile.am	2005-05-25 02:34:38 UTC (rev 78)
@@ -2,9 +2,26 @@
 bin_PROGRAMS = darimasen
 
 darimasen_SOURCES = \
+  darimasen.cpp \
+  directory.cpp \
+  main.cpp \
+  preferences.cpp \
+  tabs.cpp \
+  icon.cpp \
+  menu.cpp \
+  supplimental.cpp
 
 noinst_HEADERS = \
+  darimasen.h \
+  directory.h \
+  main.h \
+  preferences.h \
+  tabs.h \
+  icon.h \
+  menu.h \
+  supplimental.h
 
+
 AM_CXXFLAGS = -I../.. @PKG_CFLAGS@
 
 darimasen_LDADD = -lpthread @LIBS@ @PKG_LIBS@ 

Added: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/darimasen.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,14 @@
+/* Darimasen - darimasen.cpp - Copyright (C) 2005 Sudrien, GPL */
+
+#include "darimasen.h"
+
+darimasen_window::darimasen_window(std::vector<Glib::ustring> paths){
+  tabs * tabber = Gtk::manage(new class tabs(paths));
+  add(*tabber);
+  show();
+  }
+
+darimasen_window::~darimasen_window(){
+
+  }
+

Added: trunk/src/darimasen.h
===================================================================
--- trunk/src/darimasen.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/darimasen.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,19 @@
+/* Darimasen - darimasen.h - Copyright (C) 2005 Sudrien, GPL */
+
+
+#ifndef DAWINDOW_H
+#define DAWINDOW_H
+
+#include <gtkmm.h>
+#include <vector>
+#include "tabs.h"
+
+class darimasen_window : public Gtk::Window {
+  public:
+    darimasen_window(std::vector<Glib::ustring> );
+    ~darimasen_window();
+
+
+  };
+
+#endif

Added: trunk/src/darimasen.txt
===================================================================
--- trunk/src/darimasen.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/darimasen.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,20 @@
+darimasen.cs
+
+The main window. Arranges everything.
+
+Listens for signals from tabs that a tab has been switched, and:
+  sets hidden checkbox
+  makes new menu
+  orders new back button 
+  
+
+makes new tabs in begining, setting format from preferences
+
+Also has a preferences for locations menu, which is stored.
+
+That checkbox is in an options menu, which has regular stuff like 'quit' in it. 
+then the darimasen menu,
+then the back button/menu,
+then the new tab button,
+then the icon-type switch, which will send a signal to tabs,
+then a directory tree toggle if I get to it. 

Added: trunk/src/directory.cpp
===================================================================
--- trunk/src/directory.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/directory.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,17 @@
+/* Darimasen - directory.cpp - Copyright (C) 2005 Sudrien, GPL */
+
+#include "directory.h"
+
+directory::directory(){
+modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
+show();
+}
+
+
+
+
+directory::~directory(){}
+
+
+
+

Added: trunk/src/directory.h
===================================================================
--- trunk/src/directory.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/directory.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,17 @@
+/* Darimasen - directory.h - Copyright (C) 2005 Sudrien, GPL */
+
+#ifndef DIRECTORY_H
+#define DIRECTORY_H
+
+#include <gtkmm.h>
+#include <vector>
+
+class directory : public Gtk::EventBox {
+  public:
+    directory();
+    ~directory();
+
+};
+
+
+#endif

Added: trunk/src/directory.txt
===================================================================
--- trunk/src/directory.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/directory.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,15 @@
+directory.cs
+
+Holds all the icon in a directory.
+Monitors for new icons in the directory and adds them to the list.
+Gets signals from removes idons and deletes them.
+
+Decides when and where to show icons - wrapping, hidden files.
+
+Checks periodically for its own existance, sends signal to
+tabs if it does not exist. 
+
+makes icon list in begining, in the format of icon specified in preferences.
+
+recieves the mode-switch signal from tabs, deletes current table and buerries icon list for
+new mode.

Added: trunk/src/icon.cpp
===================================================================
--- trunk/src/icon.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/icon.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,30 @@
+/* Darimasen - icon.cpp - Copyright (C) 2005 Sudrien, GPL */
+
+#include "icon.h"
+
+
+/* ~_~; 
+
+icon::icon(
+    const class directory& parent,
+    const Glib::ustring& file){
+
+  Glib::RefPtr<const Gnome::Vfs::FileInfo> result;
+  icon(parent, result);
+  }
+
+/* ~_~; */
+
+icon::icon(
+    const class directory& dir,
+    Glib::RefPtr<const Gnome::Vfs::FileInfo> file){
+
+  parent = &dir;
+  file_info = file;
+  }
+
+/* ~_~; */
+
+icon::~icon(){}
+
+/* ~_~; */

Added: trunk/src/icon.h
===================================================================
--- trunk/src/icon.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/icon.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,41 @@
+/* Darimasen - icon.h - Copyright (C) 2005 Sudrien, GPL */
+
+#ifndef ICON_H
+#define ICON_H
+
+#include <glibmm.h>
+#include <gtkmm.h>
+#include <libgnomevfsmm.h>
+
+
+/* ~_~; */
+
+class icon{
+  public:
+    //icon(const class directory&, const Glib::ustring&);
+    icon(const class directory&, Glib::RefPtr<const Gnome::Vfs::FileInfo>);
+    ~icon();
+    
+    gint run() const;
+    gint run_as_text() const;
+    gint copy() const;
+    gint move() const;
+    gint link() const;
+    gint unlink() const;
+    
+    Gtk::EventBox sidecon_format() const;
+    Gtk::EventBox list_format() const;
+    void detail_format(Gtk::Table&) const;
+
+    gint set_run_action() const;
+    gint set_permissions() const;
+
+
+  private:  
+
+    Glib::RefPtr<const Gnome::Vfs::FileInfo> file_info;
+    const class directory * parent;
+
+  };
+
+#endif

Added: trunk/src/icon.txt
===================================================================
--- trunk/src/icon.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/icon.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,34 @@
+icon.cs
+
+An icon holds all the information of a file/pipe/socket/anything but a directory.
+
+These include:
+
+A name
+A mime-type
+A path
+Permissions
+owner
+group
+type
+
+... most of which can be accomplished by having a Gnome::Vfs::FileInfo member.
+
+An icon pixmap, which can be gotten from a preferences in the tabs. 
+
+One function of an icon is to give its own renditions of itself when prompted;
+ This can be a eventbox (Sidecon format, list format) or specific struct (detail view).
+
+Another function it to keep track of what it should do when called for execution;
+though this can change, only one thing can be executed at a time (with a slight delay)
+to prevent certain errors from hapening, unlike many of the file operations.
+
+An icon should regularly check if the file it is based on still exists. If it doesn't,
+a signal get sent to the directory to discard it.
+
+An icon should be able to catch signals on the deletion of non-existance of a parent
+directory (and therefore itself)
+
+Last an icon should be able to proform functions on its own file; deleting, duplicating,
+ creating a link of, setting permissions; things that can be part of a recursive operation.
+

Added: trunk/src/main.cpp
===================================================================
--- trunk/src/main.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/main.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,43 @@
+/* Darimasen - main.cpp - Copyright (C) 2005 Sudrien, GPL */
+   
+#include "main.h"
+
+
+
+int main(int argc, char *argv[]){
+
+  Gtk::Main kit(argc, argv);
+  Gnome::Vfs::init();
+
+
+  // next blocks are to check the existance of required directories.
+  // make .choices if nothing available
+  if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir())->uri_exists()){
+    gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir()).c_str(),493);
+    }
+
+  // make MIME-types if nothing available, set up basics
+  if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir() + "/MIME-types")->uri_exists()){
+    gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir() + "/MIME-types").c_str(),493);
+    //firsttime window; 
+    //Gtk::Main::run(window);
+    }
+
+  // make our own settings folder if nothing available
+  if (!Gnome::Vfs::Uri::create(Glib::get_home_dir() + get_choices_dir() + "/Darimasen")->uri_exists()){
+    gnome_vfs_make_directory((Glib::get_home_dir() + get_choices_dir() + "/Darimasen").c_str(),493);
+    }
+  
+
+  std::vector<Glib::ustring> path;
+
+  if(path.empty())
+    path.push_back(Glib::get_home_dir() + "/");
+
+
+  darimasen_window window(path);
+  Gtk::Main::run(window);
+
+
+  return 0;
+  }

Added: trunk/src/main.h
===================================================================
--- trunk/src/main.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/main.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,11 @@
+/* Darimasen - main.h - Copyright (C) 2005 Sudrien, GPL */
+   
+#ifndef MAIN_H
+#define MAIN_H
+
+#include <gtkmm/main.h>
+#include <libgnomevfsmm.h>
+#include "darimasen.h"
+#include <vector>
+
+#endif

Added: trunk/src/main.txt
===================================================================
--- trunk/src/main.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/main.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,4 @@
+startup of the program.
+
+command line parsing.
+

Added: trunk/src/menu.cpp
===================================================================

Added: trunk/src/menu.h
===================================================================

Added: trunk/src/menu.txt
===================================================================
--- trunk/src/menu.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/menu.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,14 @@
+Is given a path to build off of.
+
+It puts this into an array of strings, starting with root/home and ending
+with the current directory.
+
+Each memeber of the array gets a menu, showing the sibling directories and 
+how many subdirectories each of them have. The directory itself is at the top of
+ the list, and not present in its normal space below.
+
+The first menu is always ~/ or / ,and holds home, root, and the location menu.
+ these locations are gotten from the preferences in darimasen.
+
+THe last menu is in the form #>, where the # is the number of subdirectories
+ of the current dir, and the menu has those subdirectories and their counts. 

Added: trunk/src/preferences.cpp
===================================================================

Added: trunk/src/preferences.h
===================================================================

Added: trunk/src/preferences.txt
===================================================================
--- trunk/src/preferences.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/preferences.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,14 @@
+preferences.cs
+
+Loads preferences from last session and stores them on exit.
+
+Also can have nothing in constructor, and have no write-in/-out.
+
+They are in XML format.
+
+Is a genaric preference taker, so there is a second instance for the
+locations menu.
+
+it gets a sting and returns a value or a ""
+
+it gets two strings, the first is a name the second is a value.

Added: trunk/src/supplimental.cpp
===================================================================
--- trunk/src/supplimental.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/supplimental.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,10 @@
+
+#include "supplimental.h"
+
+/**********************/
+
+//check which choices dir to use
+Glib::ustring get_choices_dir(){
+  if (Gnome::Vfs::Uri::create(Glib::get_home_dir() + "/Choices")->uri_exists()) return "/Choices";
+  else return "/.choices";
+  }

Added: trunk/src/supplimental.h
===================================================================
--- trunk/src/supplimental.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/supplimental.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,12 @@
+/* Darimasen - supplimental.h - Copyright (C) 2005 Sudrien, GPL */
+
+#ifndef SUPPLIMENTAL_H
+#define SUPPLIMENTAL_H
+
+#include <glibmm.h>
+#include <libgnomevfsmm.h>
+
+Glib::ustring get_choices_dir();
+
+
+#endif //SUPPLIMENTAL_H

Added: trunk/src/supplimental.txt
===================================================================
--- trunk/src/supplimental.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/supplimental.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,3 @@
+Holds all functions with general application. 
+
+THis includes the enum decribing the differnt icon modes, and small marsupials, mostly those from the islands of the South Pacific.  This is arguably the most important mamillian discovery of the modern era and many proffessional and amature scientists alike, have devoted their lives and fortunes to its study.

Added: trunk/src/tabs.cpp
===================================================================
--- trunk/src/tabs.cpp	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/tabs.cpp	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,181 @@
+/* Darimasen - tabs.cpp - Copyright (C) 2005 Sudrien, GPL */
+
+#include "tabs.h"
+
+
+/**********************/
+
+tabs::tabs(const std::vector<Glib::ustring>& input){
+
+  // begin the history  
+  for(gint i = 0; i < input.size(); i++){
+    set_history(i, input[i]);
+    add_tab(i);
+    }
+  show_all_children();
+  show();
+  }
+
+/**********************/
+
+tabs::~tabs(){}
+
+/**********************/
+
+void tabs::add_tab(gint pos){
+
+
+ // if( get_n_pages() == 0 )
+ //   set_show_tabs(false);
+ // else
+    set_show_tabs(true);
+
+
+  Gtk::Image * xed = Gtk::manage(
+    new Gtk::Image("/usr/share/icons/hicolor/16x16/stock/generic/stock_close.png"));
+  xed->show();
+
+  Gtk::Label * tabNum;
+
+  if ( get_history(pos) == "/")
+    tabNum = Gtk::manage(new Gtk::Label("/ "));
+  else if ( get_history(pos) == (Glib::get_home_dir() + "/"))
+    tabNum = Gtk::manage(new Gtk::Label("~/ "));
+  else
+    tabNum = Gtk::manage(new Gtk::Label(
+      get_history(pos).substr(get_history(pos).rfind("/",get_history(pos).length() - 2  ) + 1)));
+
+
+  Gtk::HBox * arrangement= Gtk::manage(new Gtk::HBox()) ;
+  Gtk::Button * closeButton = Gtk::manage(new Gtk::Button());
+
+  closeButton->add(*xed);
+  closeButton->set_relief(Gtk::RELIEF_NONE); 
+  closeButton->show();
+
+
+
+
+  tabNum->show();
+  arrangement->show();
+
+  arrangement->pack_start(*tabNum);
+  arrangement->pack_end(*closeButton);
+
+ // Gtk::EventBox * MainEventBox = new class Gtk::EventBox;
+
+
+ // MainEventBox->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
+ // MainEventBox->show();
+
+  //DaIconModes * foo;
+  //foo = new class DaIconModes(pos, *this);
+
+
+  // pos can't be the thing passed here, it changes... (segfault: 3 tabs, close 2nd then 3rd)
+  //closeButton->signal_clicked().connect(
+  //  sigc::bind<DaIconModes*>(sigc::mem_fun(*this, &Darimasen::removeTab), foo) );
+
+
+/*
+  if ( IconModeList.size() == pos ){
+  //  IconModeList.push_badirectory * dir = Gtk::manage(new class directory(*this,pos))ck(foo);
+  //  EventBoxList.push_back(MainEventBox);
+    }
+  else {
+    delete IconModeList[pos];
+    IconModeList[pos] = foo;
+    delete EventBoxList[pos];
+    EventBoxList[pos] = MainEventBox;
+    }*/
+
+ // Gtk::ScrolledWindow * MainScroller = new Gtk::ScrolledWindow;
+ // MainScroller->show();
+ // MainScroller->set_shadow_type(Gtk::SHADOW_NONE);
+  //MainScroller->add(*MainEventBox);
+  //MainEventBox->add(*foo);
+  //MainScroller->set_policy(Gtk::POLICY_ALWAYS, Gtk::POLICY_AUTOMATIC);
+  //foo->show();
+
+ // Gtk::EventBox * MainEventBox = new class Gtk::EventBox;
+
+
+ // MainEventBox->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
+
+  //directory * dir = Gtk::manage(new class directory(*this,pos))
+  directory * dir = Gtk::manage(new class directory());
+  insert_page( *dir, *arrangement, pos);
+
+
+
+  }
+
+/**********************/
+
+Glib::RefPtr<Gdk::Pixbuf> tabs::get_icon(Glib::ustring mime){
+  int i;
+
+  for(i = 0; i< mimeList.size(); i++){
+    if( mime == mimeList[i] ){
+      return unsizedImg[i];
+      }
+    }
+   // pic doesn't exist.
+
+    Glib::ustring ico;
+  try{
+    ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
+    ico += mime.replace(mime.find("/"), 1, "-");
+    ico += ".png";
+
+    Glib::file_get_contents(ico);
+    }
+  catch(const Glib::Error) {
+    try{
+      ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
+      ico += mime.substr(0,mime.find("-"));
+      ico += ".png";
+      Glib::file_get_contents(ico);
+      }
+    catch(const Glib::Error) {
+     ico = "/usr/share/icons/gnome/48x48/filesystems/gnome-fs-loading-icon.png";
+     }
+    }
+
+  mimeList.push_back(mime);
+  Glib::RefPtr<Gdk::Pixbuf> xe = Gdk::Pixbuf::create_from_file(ico);
+  unsizedImg.push_back(xe);
+  return unsizedImg[i]; 
+  }
+
+/**********************/
+
+Glib::ustring tabs::get_history(gint tab, gint level) const{
+  return history[tab][history[tab].size()-level-1];
+  }
+
+/**********************/
+
+void tabs::set_history(gint tab, Glib::ustring path){
+  if (get_n_pages() == tab){
+    std::vector<Glib::ustring> empty;
+    history.push_back(empty);
+    history[tab].push_back(path);
+    }
+  else {
+    history[tab].push_back(path);
+    }
+  }
+
+/**********************/
+
+gint tabs::rm_history(gint tab){
+  history[tab].pop_back();
+  if ( history[tab].size() == 0 ){
+    history.erase(history.begin()+tab,history.begin()+tab+1 );
+    return 0;
+    }
+  return history[tab].size();
+  }
+
+/**********************/

Added: trunk/src/tabs.h
===================================================================
--- trunk/src/tabs.h	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/tabs.h	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,33 @@
+/* Darimasen - tabs.h - Copyright (C) 2005 Sudrien, GPL */
+
+#ifndef TABS_H
+#define TABS_H
+
+#include <gtkmm.h>
+#include <vector>
+#include "supplimental.h"
+#include "directory.h"
+
+class tabs : public Gtk::Notebook {
+  public:
+    tabs(const std::vector<Glib::ustring>&);
+    ~tabs();
+
+
+    void set_history(gint, Glib::ustring);
+    Glib::ustring get_history(gint, gint = 0) const;
+    gint rm_history(gint);
+
+    Glib::RefPtr<Gdk::Pixbuf> get_icon(Glib::ustring);
+
+  private:
+    void add_tab(gint);
+    //signal_switch_page().connect(sigc::mem_fun(*this, &Darimasen::tabberSwitched));
+
+    std::vector< std::vector <Glib::ustring> > history;
+
+    std::vector< Glib::ustring > mimeList;
+    std::vector< Glib::RefPtr<Gdk::Pixbuf> > unsizedImg;
+};
+
+#endif

Added: trunk/src/tabs.txt
===================================================================
--- trunk/src/tabs.txt	2005-05-23 03:07:19 UTC (rev 77)
+++ trunk/src/tabs.txt	2005-05-25 02:34:38 UTC (rev 78)
@@ -0,0 +1,18 @@
+tab.cs
+
+This is what holds sets of icons. It is a Gtk::Notebook, along with managing
+the current directories.
+
+This is the class you query and set for all history operations.
+This is the class you tell to update thus-and-such directory.
+
+recieves I-don't-exist signal from directory, and deletes it directory instance and tab.
+Tries to make a new tab of a parent directory in its place.
+
+Sends dignal up to darimasen when a tab is switched, giving the new path.
+Sends up same signal when a location is no longer valid.
+
+Recieves signals for new tabs from darimasen.
+passes the switch-icon signal on to each directory
+
+A preferences for icon pixmaps, which aren't written out, but are requested during icon creation.



From darimasen-svn-admin at lists.berlios.de  Fri May 27 15:18:33 2005
From: darimasen-svn-admin at lists.berlios.de (darimasen-svn-admin at lists.berlios.de)
Date: Fri, 27 May 2005 15:18:33 +0200
Subject: [Darimasen-svn] r79 - trunk/src
Message-ID: <200505271318.j4RDIXvX030106@sheep.berlios.de>

Author: sudrien
Date: 2005-05-27 15:18:32 +0200 (Fri, 27 May 2005)
New Revision: 79

Modified:
   trunk/src/directory.cpp
   trunk/src/directory.h
   trunk/src/icon.cpp
   trunk/src/icon.h
   trunk/src/tabs.cpp
Log:
listview implementation

Modified: trunk/src/directory.cpp
===================================================================
--- trunk/src/directory.cpp	2005-05-25 02:34:38 UTC (rev 78)
+++ trunk/src/directory.cpp	2005-05-27 13:18:32 UTC (rev 79)
@@ -2,16 +2,145 @@
 
 #include "directory.h"
 
-directory::directory(){
-modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
-show();
+directory::directory(class tabs & ancestor, gint pos){
+
+  modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
+
+  parent = &ancestor;
+position = pos;
+  // prepare the listing
+  add(scroller);
+  scroller.add(tree_view);
+  tree_model = Gtk::ListStore::create(icon_list);
+  tree_view.set_model(tree_model);
+  tree_view.append_column("Icon", icon_list.icon_pixmap); 
+  tree_view.append_column("File Name", icon_list.file_name);
+
+
+
+  //get the stuff for this directory
+  try { // make all those files into proto_icons
+    Gnome::Vfs::DirectoryHandle::visit(
+      parent->get_history(position),
+      Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
+      Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
+      Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
+      sigc::mem_fun(*this,&directory::add_file));
+    }
+  catch(const Gnome::Vfs::exception& ex){}
+  
+  
+ // tree_model->set_sort_column(1,Gtk::SORT_ASCENDING);
+
+  tree_model->set_sort_func(1,
+
+      sigc::mem_fun(*this, &directory::sort_list_func));
+
+
+  show();
 }
 
+bool directory::add_file(    Glib::ustring rel_path,
+    Glib::RefPtr<const Gnome::Vfs::FileInfo> file,
+    bool recursing_will_loop,
+    bool recurse){
 
 
+/*
 
+  if (file->get_type() != Gnome::Vfs::FILE_TYPE_DIRECTORY){
+
+  Gtk::TreeModel::Row row = *(tree_model->append());
+std::cout << file->get_mime_type() << "\n";
+
+Glib::ustring n = file->get_mime_type();
+parent->get_icon(n.c_str());
+  //row[icon_list.icon_pixmap] = parent->get_icon(file->get_mime_type());
+
+
+  row[icon_list.file_name] = file->get_name();
+
+
+
+
+    }
+  else {
+    Glib::RefPtr<Gnome::Vfs::Uri> x = Gnome::Vfs::Uri::create(
+      parent->get_history(position) + file->get_name() + "/.DirIcon");
+      if (x->uri_exists()){
+
+  Gtk::TreeModel::Row row = *(tree_model->append());
+//std::cout << file->get_mime_type() << "\n";
+
+//Glib::ustring n = file->get_mime_type();
+//parent->get_icon(n.c_str());
+  //row[icon_list.icon_pixmap] = parent->get_icon(file->get_mime_type());
+
+
+  row[icon_list.file_name] = file->get_name();
+
+
+        }
+    }
+
+*/
+
+  if (file->get_type() != Gnome::Vfs::FILE_TYPE_DIRECTORY ||
+      Gnome::Vfs::Uri::create(rel_path + file->get_name() + "/.DirIcon")->uri_exists()){
+    //file_list.push_back(*file);
+    //std::cout << file_list.back()->get_name() << "\n";
+  Gtk::TreeModel::Row row = *(tree_model->append());
+    row[icon_list.file_name] = file->get_name();
+    }
+
+  return true;
+  }
+
+
 directory::~directory(){}
 
+/*
+void directory::render(){
 
+  Gtk::TreeModel::Row row = *(tree_model->append());
+  for(int i=0; i < file_list.size(); i++){
+    std::cout << file_list[i]->get_name() << "\n";
+    row[icon_list.file_name] = file_list[i]->get_name();
+    row = *(tree_model->append());
+    }
 
 
+  }
+*/
+
+
+
+int directory::sort_list_func(const Gtk::TreeModel::iterator& A, const Gtk::TreeModel::iterator& B){
+  
+Glib::ustring n = (*A)->get_value(icon_list.file_name);
+Glib::ustring b = (*A)->get_value(icon_list.file_name);
+//std::cout << n <<"\n";
+//Gtk::TreeModel::Row row = *(A);
+//Gtk::TreeModel::Row row2 = *(B);
+
+
+//std::cout <<  row[icon_list.file_name] << " " << row2[icon_list.file_name] << "\n";
+
+  if(n.substr(0,1) == "." && b.substr(0,1) != ".")
+    return -1;
+
+  if(n.substr(0,1) != "." && b.substr(0,1) == ".")
+    return 1;
+
+
+  if(n > b){
+
+    return -1;
+
+    }
+
+  if(n < b)
+    return 1;
+
+return 0;
+}

Modified: trunk/src/directory.h
===================================================================
--- trunk/src/directory.h	2005-05-25 02:34:38 UTC (rev 78)
+++ trunk/src/directory.h	2005-05-27 13:18:32 UTC (rev 79)
@@ -5,13 +5,35 @@
 
 #include <gtkmm.h>
 #include <vector>
+#include "icon.h"
+#include "tabs.h"
+#include <iostream>
 
 class directory : public Gtk::EventBox {
   public:
-    directory();
+    directory(class tabs&, gint);
     ~directory();
 
-};
+  private:
 
+  class tabs * parent;
+  gint position;
 
+  class icon icon_list;
+  Gtk::ScrolledWindow scroller;
+
+  Gtk::TreeView tree_view;
+  Glib::RefPtr< Gtk::ListStore > tree_model;
+
+  
+  std::vector< Glib::RefPtr<const Gnome::Vfs::FileInfo > > file_list;
+
+
+  bool add_file(Glib::ustring,Glib::RefPtr<const Gnome::Vfs::FileInfo>, bool, bool);
+  int sort_list_func(const Gtk::TreeModel::iterator&, const Gtk::TreeModel::iterator&);
+
+//  void render();
+  };
+
+
 #endif

Modified: trunk/src/icon.cpp
===================================================================
--- trunk/src/icon.cpp	2005-05-25 02:34:38 UTC (rev 78)
+++ trunk/src/icon.cpp	2005-05-27 13:18:32 UTC (rev 79)
@@ -13,7 +13,7 @@
   icon(parent, result);
   }
 
-/* ~_~; */
+/* ~_~; 
 
 icon::icon(
     const class directory& dir,
@@ -21,10 +21,22 @@
 
   parent = &dir;
   file_info = file;
+
+
+
+
   }
 
 /* ~_~; */
 
+icon::icon(){
+    add(icon_pixmap);
+    //add(file_info);
+    add(file_name);
+  }
+
+/* ~_~; */
+
 icon::~icon(){}
 
 /* ~_~; */

Modified: trunk/src/icon.h
===================================================================
--- trunk/src/icon.h	2005-05-25 02:34:38 UTC (rev 78)
+++ trunk/src/icon.h	2005-05-27 13:18:32 UTC (rev 79)
@@ -10,10 +10,11 @@
 
 /* ~_~; */
 
-class icon{
+class icon : public Gtk::TreeModel::ColumnRecord{
   public:
     //icon(const class directory&, const Glib::ustring&);
-    icon(const class directory&, Glib::RefPtr<const Gnome::Vfs::FileInfo>);
+    //icon(const class directory&, Glib::RefPtr<const Gnome::Vfs::FileInfo>);
+    icon();
     ~icon();
     
     gint run() const;
@@ -31,11 +32,18 @@
     gint set_permissions() const;
 
 
+    Gtk::TreeModelColumn< Glib::RefPtr<Gdk::Pixbuf> > icon_pixmap;
+    //Gtk::TreeModelColumn< Glib::RefPtr<Gnome::Vfs::FileInfo> > file_info;
+    Gtk::TreeModelColumn< Glib::ustring > file_name;
+
   private:  
 
-    Glib::RefPtr<const Gnome::Vfs::FileInfo> file_info;
-    const class directory * parent;
+    //Glib::RefPtr<const Gnome::Vfs::FileInfo> file_info;
+    //const class directory * parent;
 
+
+    
+
   };
 
 #endif

Modified: trunk/src/tabs.cpp
===================================================================
--- trunk/src/tabs.cpp	2005-05-25 02:34:38 UTC (rev 78)
+++ trunk/src/tabs.cpp	2005-05-27 13:18:32 UTC (rev 79)
@@ -102,8 +102,8 @@
 
  // MainEventBox->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
 
-  //directory * dir = Gtk::manage(new class directory(*this,pos))
-  directory * dir = Gtk::manage(new class directory());
+  directory * dir = Gtk::manage(new class directory(*this,pos));
+  //directory * dir = Gtk::manage(new class directory());
   insert_page( *dir, *arrangement, pos);
 
 
@@ -122,25 +122,26 @@
     }
    // pic doesn't exist.
 
-    Glib::ustring ico;
+    Glib::ustring ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
+Glib::ustring t;
   try{
-    ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
-    ico += mime.replace(mime.find("/"), 1, "-");
-    ico += ".png";
+    t = mime.replace(mime.find("/"), 1, "-");
+    t += ".png";
 
     Glib::file_get_contents(ico);
     }
   catch(const Glib::Error) {
     try{
-      ico = "/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-";
-      ico += mime.substr(0,mime.find("-"));
-      ico += ".png";
+      t = mime.substr(0,mime.find("-"));
+      t += ".png";
       Glib::file_get_contents(ico);
       }
     catch(const Glib::Error) {
      ico = "/usr/share/icons/gnome/48x48/filesystems/gnome-fs-loading-icon.png";
+     t = "";
      }
     }
+ico += t;
 
   mimeList.push_back(mime);
   Glib::RefPtr<Gdk::Pixbuf> xe = Gdk::Pixbuf::create_from_file(ico);



