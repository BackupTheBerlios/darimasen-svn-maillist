<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Darimasen-svn] r56 - trunk/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/darimasen-svn/2005-April/index.html" >
   <LINK REL="made" HREF="mailto:darimasen-svn%40lists.berlios.de?Subject=Re%3A%20%5BDarimasen-svn%5D%20r56%20-%20trunk/src&In-Reply-To=%3C200504191826.j3JIQqbK019245%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000008.html">
   <LINK REL="Next"  HREF="000010.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Darimasen-svn] r56 - trunk/src</H1>
    <B>darimasen-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:darimasen-svn%40lists.berlios.de?Subject=Re%3A%20%5BDarimasen-svn%5D%20r56%20-%20trunk/src&In-Reply-To=%3C200504191826.j3JIQqbK019245%40sheep.berlios.de%3E"
       TITLE="[Darimasen-svn] r56 - trunk/src">darimasen-svn-admin at lists.berlios.de
       </A><BR>
    <I>Tue Apr 19 20:26:52 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000008.html">[Darimasen-svn] r55 - trunk/src
</A></li>
        <LI>Next message: <A HREF="000010.html">[Darimasen-svn] r57 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: sudrien
Date: 2005-04-19 20:26:51 +0200 (Tue, 19 Apr 2005)
New Revision: 56

Added:
   trunk/src/damenu.cpp
   trunk/src/damenu.h
Modified:
   trunk/src/Makefile.am
   trunk/src/darimasen.cpp
   trunk/src/darimasen.h
   trunk/src/iconmodes.cpp
   trunk/src/iconmodes.h
Log:
revert to r53, seperate damenu

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/Makefile.am	2005-04-19 18:26:51 UTC (rev 56)
@@ -7,6 +7,7 @@
 	supplimental.cpp \
         firsttime.cpp \
 	main.cpp \
+	damenu.cpp \
         prefix.c
 
 noinst_HEADERS = \
@@ -15,6 +16,7 @@
 	supplimental.h \
         firsttime.h \
 	main.h \
+	damenu.h \
         prefix.h
 
 

Added: trunk/src/damenu.cpp
===================================================================
--- trunk/src/damenu.cpp	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/damenu.cpp	2005-04-19 18:26:51 UTC (rev 56)
@@ -0,0 +1,346 @@
+
+/* Darimasen - damenu.cpp - Copyright (C) 2004 - 2005 Sudrien, GPL */
+
+/**********************/
+
+#include &quot;damenu.h&quot;
+
+
+/**********************/
+
+
+// what actually builds the menus for each directory.
+void DarimasenMenu::MenuForPath(
+       int position,
+       Glib::ustring path,
+       Glib::ustring ext){
+
+  int entry = 0;
+
+MenuItemArray[position]-&gt;signal_activate().connect_notify(sigc::bind&lt;guint,Glib::ustring&gt;(sigc::mem_fun(*this,&amp;DarimasenMenu:: selection_reset),position,path));
+
+  if( position &lt; depth || ext != &quot;&quot;){
+
+    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem(menulevel[position] + &quot; &quot;));
+    MenuArray[position]-&gt;attach(*subdir, 0 ,4, entry++, entry+1);
+    subdir-&gt;show();
+
+          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
+
+    if ( ext != &quot;&quot; ){
+          subdir-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,true));
+      }
+    else {
+          subdir-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,false));
+      }
+
+    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
+    MenuArray[position]-&gt;attach(*sep, 0 ,4, entry++, entry+1);
+    sep-&gt;show();
+    }
+
+  try{
+    Gnome::Vfs::DirectoryHandle handle;
+
+    if(ext == &quot;&quot;){
+      handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
+      }
+    else{
+      handle.open(path + slash + ext, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
+      }
+
+    bool file_exists = true;
+    while(file_exists) {
+      Glib::RefPtr&lt;Gnome::Vfs::FileInfo&gt; refFileInfo = handle.read_next(file_exists);
+      if (refFileInfo-&gt;get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
+          &amp;&amp; ( (refFileInfo-&gt;get_name().substr(0,1) != &quot;.&quot;) || parent-&gt;optShowHidden-&gt;get_active() )
+          &amp;&amp; refFileInfo-&gt;get_name() != &quot;.&quot;
+          &amp;&amp; refFileInfo-&gt;get_name() != &quot;..&quot;
+          ){ 
+        Gtk::MenuItem * subdir;
+        Glib::ustring SubSubCount;
+        if(ext == &quot;&quot;){
+          subdir = Gtk::manage( new Gtk::MenuItem(refFileInfo-&gt;get_name() + slash + &quot; &quot;));
+          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
+
+          subdir-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                 (path + refFileInfo-&gt;get_name()), position,false));
+
+          SubSubCount = CountSubdir(path + refFileInfo-&gt;get_name());
+          }
+        else{
+          subdir = Gtk::manage( new Gtk::MenuItem(ext + slash + refFileInfo-&gt;get_name() + slash + &quot; &quot;));
+
+
+          subdir-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                (path + ext.substr(1) + slash + refFileInfo-&gt;get_name()), position,false));
+
+          SubSubCount = CountSubdir(path + ext + slash + refFileInfo-&gt;get_name());
+          }
+
+        if (SubSubCount != &quot;0&quot;){
+          Gtk::Label * SubSubLabel = Gtk::manage(new class Gtk::Label(SubSubCount + &quot; \342\226\272&quot;,1,0.5));
+          SubSubLabel-&gt;show();
+          Gtk::MenuItem * subsubdir = Gtk::manage( new Gtk::MenuItem(*SubSubLabel));
+          subsubdir-&gt;set_right_justified();
+
+
+          subsubdir-&gt;signal_button_release_event().connect(
+            sigc::bind&lt;int, Glib::ustring, Glib::ustring&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::SpecialMenuForPath),
+                position, path, ext+ slash + refFileInfo-&gt;get_name()));
+
+          MenuArray[position]-&gt;attach(*subsubdir, 3 ,4, entry, entry+1);
+          subsubdir-&gt;show();
+          MenuArray[position]-&gt;attach(*subdir, 0 ,3, entry++, entry+1);
+          subdir-&gt;show();
+          }
+        else {
+          MenuArray[position]-&gt;attach(*subdir, 0 ,4, entry++, entry+1);
+          subdir-&gt;show();            
+          }
+        }
+      }
+    }
+  catch(const Gnome::Vfs::exception&amp; ex){}
+
+
+  }
+
+/**********************/
+
+// the function called for sub-sub-directories - when an arrow is selected in another menu. 
+bool DarimasenMenu::SpecialMenuForPath(GdkEventButton* event,
+       int position,
+       Glib::ustring path,
+       Glib::ustring ext){
+
+  MenuItemArray[position]-&gt;remove_submenu();
+  delete MenuArray[position];
+  MenuArray[position] =  new DirectoryMenu(*this);
+  MenuItemArray[position]-&gt;set_submenu(*MenuArray[position]);
+  MenuForPath(position, path, ext);
+  MenuItemArray[position]-&gt;select();
+
+  needsRebuild[position] = true;
+
+  return true;
+
+  }
+
+/**********************/
+
+void DarimasenMenu:: selection_reset(guint position, Glib::ustring path){
+  if ( needsRebuild[position] ){
+    MenuItemArray[position]-&gt;remove_submenu();
+    delete MenuArray[position];
+    MenuArray[position] =  new DirectoryMenu(*this);
+    MenuItemArray[position]-&gt;set_submenu(*MenuArray[position]);
+    MenuForPath(position, path, &quot;&quot;);
+    MenuItemArray[position]-&gt;select();
+
+    needsRebuild[position] = false;
+    }
+}
+
+/**********************/
+
+//Decides the action of the menuItem, more sophisticated than the activate signal. 
+//its comment should always be somewhere.
+
+bool DarimasenMenu::DaMenuSelect(
+      GdkEventButton* event,
+      const Glib::ustring path,
+      guint pos,
+      bool first){
+
+  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 2) ) //middle
+  {
+  parent-&gt;newTab(path);
+  return true;
+  }
+  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 1) ) //left
+  {
+  parent-&gt;ChangeCurrentPath(path,true,first);
+  return true;
+  }
+  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) ) //right
+  {
+    Gtk::Menu * m_Menu_Popup = Gtk::manage( new Gtk::Menu);
+    m_Menu_Popup-&gt;items().push_back( Gtk::Menu_Helpers::MenuElem(&quot;Open In new Tab&quot;));
+    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);
+  return true;
+   }
+
+  return false;
+
+  //DaFileLister(); //5:45pm, 24 Dec 2004, it worked! // leave this comment    
+  }
+
+/**********************/
+
+// provides the numbers by the arrows. 
+Glib::ustring DarimasenMenu::CountSubdir(const Glib::ustring&amp; path){
+  int j=0;
+  try{
+    Gnome::Vfs::DirectoryHandle handle;
+    handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
+
+    bool file_exists = true;
+    while(file_exists){
+
+      Glib::RefPtr&lt;Gnome::Vfs::FileInfo&gt; refFileInfo = handle.read_next(file_exists);
+      if (refFileInfo-&gt;get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
+        &amp;&amp; ( (refFileInfo-&gt;get_name().substr(0,1) != &quot;.&quot;) || parent-&gt;optShowHidden-&gt;get_active())
+        &amp;&amp; refFileInfo-&gt;get_name() != &quot;.&quot;
+        &amp;&amp; refFileInfo-&gt;get_name() != &quot;..&quot;){
+        j++;
+        }
+      }
+    }
+  catch(const Gnome::Vfs::exception&amp; ex){}
+  return int2ustr(j);
+
+}
+
+/**********************/
+
+// parses the path, builds the menu bar. 
+DarimasenMenu::DarimasenMenu(const Glib::ustring &amp; path, Darimasen&amp; Myparent, guint pos){
+
+  depth = 0;
+
+  Glib::ustring shortpath = path; //home = getenv(&quot;HOME&quot;);
+  parent = &Myparent;
+  
+  int startPos = 0 , i = 0;
+
+
+  if ( path.find(getenv(&quot;HOME&quot;)) != Glib::ustring::npos ){
+    shortpath.replace(0,((Glib::ustring)getenv(&quot;HOME&quot;)).length(),&quot;~&quot;);
+    }
+
+  while ( (shortpath.find(slash,startPos) != Glib::ustring::npos) ) {
+    startPos = shortpath.find(slash,startPos) + 1; depth++;
+    }
+
+  menulevel =  new Glib::ustring[depth+1];
+  needsRebuild = new bool[depth+1];
+  for( int i=0; i&lt;=depth; i++)
+        needsRebuild[i] = false;
+
+
+  startPos = 0;
+  for(i = 0; shortpath.find(slash,startPos) !=  Glib::ustring::npos ; i++ ){
+    menulevel[i] = shortpath.substr(startPos,shortpath.find(slash,startPos) - startPos + 1 );
+    startPos = shortpath.find(slash,startPos) + 1;
+    };
+  menulevel[depth] = &quot;.&quot;;
+
+  MenuArray = new DirectoryMenu*[depth+1];
+  MenuItemArray = new Gtk::MenuItem*[depth+1];
+
+  for(int c = 0; c &lt; depth+1; c++){
+    MenuArray[c] =  new DirectoryMenu(*this);
+    }
+ 
+    Glib::ustring subin = CountSubdir(path);
+    if ( subin != &quot;0&quot; ){
+      MenuItemArray[depth] =  new Gtk::MenuItem( subin + &quot; \342\226\272&quot; );
+      MenuItemArray[depth]-&gt;show();
+      MenuItemArray[depth]-&gt;set_submenu(*MenuArray[depth]);
+      prepend(*MenuItemArray[depth]);
+      MenuForPath(depth, path, &quot;&quot;);
+      }
+  
+  Glib::ustring crop = path;
+
+
+  for(i = depth - 1; i&gt;0; i--){
+    crop = crop.substr(0, crop.rfind(slash,crop.length()-2)) + slash;
+
+    MenuItemArray[i] = new Gtk::MenuItem(underscoreSafe(menulevel[i]) );
+    MenuItemArray[i]-&gt;show();
+    MenuItemArray[i]-&gt;set_submenu(*MenuArray[i]);
+    prepend(*MenuItemArray[i]);
+    MenuForPath(i, crop, &quot;&quot;);
+    }
+
+  MenuItemArray[i] = new Gtk::MenuItem(underscoreSafe(menulevel[i] ));
+  MenuItemArray[i]-&gt;show();
+  prepend(*MenuItemArray[i]);
+
+
+
+// root stuff
+    MenuItemArray[0]-&gt;set_submenu(*MenuArray[0]);
+    MenuItemArray[0]-&gt;show();
+    MenuArray[0]-&gt;show();
+
+    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem(&quot;/ (root)&quot;));
+    MenuArray[0]-&gt;attach(*subdir, 0 ,1, 0, 1);
+    subdir-&gt;show();
+
+          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
+
+          subdir-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                 &quot;/&quot;,pos,false));
+
+
+
+    Gtk::MenuItem * subdir2 = Gtk::manage( new Gtk::MenuItem(&quot;~ (home)&quot;));
+    MenuArray[0]-&gt;attach(*subdir2, 0 ,1, 1, 2);
+    subdir2-&gt;show();
+
+          subdir2-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
+
+          subdir2-&gt;signal_button_press_event().connect(
+            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
+              sigc::mem_fun(*this, &amp;DarimasenMenu::DaMenuSelect),
+                getenv(&quot;HOME&quot;),pos,false));
+
+    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
+    MenuArray[0]-&gt;attach(*sep, 0 ,1, 2, 3);
+    sep-&gt;show();
+
+    Gtk::MenuItem * subdir3 = Gtk::manage( new Gtk::MenuItem(&quot;Add a location to this list&quot;));
+    MenuArray[0]-&gt;attach(*subdir3, 0 ,1, 3, 4);
+    subdir3-&gt;set_sensitive(false);
+    subdir3-&gt;show();
+
+
+  show();
+
+  }
+
+/**********************/
+
+// cleanup on asile 9. More might me Gtk::manageable...
+DarimasenMenu::~DarimasenMenu(){
+  for(int c = 0; c &lt; depth+1; c++){
+    delete MenuArray[c];
+    }
+  delete menulevel;
+  delete needsRebuild;
+  for (int i = 0; i &lt;=depth; i++){
+    delete MenuArray[i];
+    delete MenuItemArray[i];
+    }
+  
+  }
+
+/**********************/
+
+

Added: trunk/src/damenu.h
===================================================================
--- trunk/src/damenu.h	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/damenu.h	2005-04-19 18:26:51 UTC (rev 56)
@@ -0,0 +1,62 @@
+/* Darimasen - darimasen.h - Copyright (C) 2004 - 2005 Sudrien, GPL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+
+#ifndef DAMENU_H
+#define DAMENU_H
+
+
+#include &lt;gtkmm.h&gt;
+#include &quot;darimasen.h&quot;
+#include &lt;iostream&gt;
+
+  class DarimasenMenu : public Gtk::MenuBar {
+
+    class DirectoryMenu : public Gtk::Menu {
+    public:
+      DirectoryMenu(DarimasenMenu&amp; in ){
+        Gtk::Menu::Menu();
+        }
+      };
+
+
+    class Darimasen * parent;
+
+    int depth;
+
+    DirectoryMenu ** MenuArray; 
+    Gtk::MenuItem ** MenuItemArray;
+    Glib::ustring * menulevel;
+
+    void MenuForPath(int, Glib::ustring , Glib::ustring); //extension
+    bool SpecialMenuForPath(GdkEventButton* , int, Glib::ustring  , Glib::ustring); //extension
+
+    Glib::ustring CountSubdir(const Glib::ustring&amp;);
+    bool DaMenuSelect(GdkEventButton*, const Glib::ustring,guint,bool);
+    void selection_reset(guint, Glib::ustring);
+ 
+    bool * needsRebuild;
+  public:
+
+    void signal_deactivate ();
+    DarimasenMenu(const Glib::ustring&amp;, class Darimasen&amp;, guint);
+    ~DarimasenMenu();
+
+    };
+
+/**********************/
+
+#endif //DAMENU_H

Modified: trunk/src/darimasen.cpp
===================================================================
--- trunk/src/darimasen.cpp	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/darimasen.cpp	2005-04-19 18:26:51 UTC (rev 56)
@@ -5,343 +5,9 @@
 #include &quot;darimasen.h&quot;
 #include &lt;iostream&gt;
 
-/**********************/
 
-
-// what actually builds the menus for each directory.
-void Darimasen::DarimasenMenu::MenuForPath(
-       int position,
-       Glib::ustring path,
-       Glib::ustring ext){
-
-  int entry = 0;
-
-MenuItemArray[position]-&gt;signal_activate().connect_notify(sigc::bind&lt;guint,Glib::ustring&gt;(sigc::mem_fun(*this,&amp;Darimasen::DarimasenMenu:: selection_reset),position,path));
-
-  if( position &lt; depth || ext != &quot;&quot;){
-
-    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem(menulevel[position] + &quot; &quot;));
-    MenuArray[position]-&gt;attach(*subdir, 0 ,4, entry++, entry+1);
-    subdir-&gt;show();
-
-          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-
-    if ( ext != &quot;&quot; ){
-          subdir-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,true));
-      }
-    else {
-          subdir-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                 (path + menulevel[position]).substr(0, (path + menulevel[position]).length() - 1),position,false));
-      }
-
-    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
-    MenuArray[position]-&gt;attach(*sep, 0 ,4, entry++, entry+1);
-    sep-&gt;show();
-    }
-
-  try{
-    Gnome::Vfs::DirectoryHandle handle;
-
-    if(ext == &quot;&quot;){
-      handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-      }
-    else{
-      handle.open(path + slash + ext, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-      }
-
-    bool file_exists = true;
-    while(file_exists) {
-      Glib::RefPtr&lt;Gnome::Vfs::FileInfo&gt; refFileInfo = handle.read_next(file_exists);
-      if (refFileInfo-&gt;get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
-          &amp;&amp; ( (refFileInfo-&gt;get_name().substr(0,1) != &quot;.&quot;) || parent-&gt;optShowHidden-&gt;get_active() )
-          &amp;&amp; refFileInfo-&gt;get_name() != &quot;.&quot;
-          &amp;&amp; refFileInfo-&gt;get_name() != &quot;..&quot;
-          ){ 
-        Gtk::MenuItem * subdir;
-        Glib::ustring SubSubCount;
-        if(ext == &quot;&quot;){
-          subdir = Gtk::manage( new Gtk::MenuItem(refFileInfo-&gt;get_name() + slash + &quot; &quot;));
-          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                 (path + refFileInfo-&gt;get_name()), position,false));
-
-          SubSubCount = CountSubdir(path + refFileInfo-&gt;get_name());
-          }
-        else{
-          subdir = Gtk::manage( new Gtk::MenuItem(ext + slash + refFileInfo-&gt;get_name() + slash + &quot; &quot;));
-
-
-          subdir-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                (path + ext.substr(1) + slash + refFileInfo-&gt;get_name()), position,false));
-
-          SubSubCount = CountSubdir(path + ext + slash + refFileInfo-&gt;get_name());
-          }
-
-        if (SubSubCount != &quot;0&quot;){
-          Gtk::Label * SubSubLabel = Gtk::manage(new class Gtk::Label(SubSubCount + &quot; \342\226\272&quot;,1,0.5));
-          SubSubLabel-&gt;show();
-          Gtk::MenuItem * subsubdir = Gtk::manage( new Gtk::MenuItem(*SubSubLabel));
-          subsubdir-&gt;set_right_justified();
-
-
-          subsubdir-&gt;signal_button_release_event().connect(
-            sigc::bind&lt;int, Glib::ustring, Glib::ustring&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::SpecialMenuForPath),
-                position, path, ext+ slash + refFileInfo-&gt;get_name()));
-
-          MenuArray[position]-&gt;attach(*subsubdir, 3 ,4, entry, entry+1);
-          subsubdir-&gt;show();
-          MenuArray[position]-&gt;attach(*subdir, 0 ,3, entry++, entry+1);
-          subdir-&gt;show();
-          }
-        else {
-          MenuArray[position]-&gt;attach(*subdir, 0 ,4, entry++, entry+1);
-          subdir-&gt;show();            
-          }
-        }
-      }
-    }
-  catch(const Gnome::Vfs::exception&amp; ex){}
-
-
-  }
-
 /**********************/
 
-// the function called for sub-sub-directories - when an arrow is selected in another menu. 
-bool Darimasen::DarimasenMenu::SpecialMenuForPath(GdkEventButton* event,
-       int position,
-       Glib::ustring path,
-       Glib::ustring ext){
-
-  MenuItemArray[position]-&gt;remove_submenu();
-  delete MenuArray[position];
-  MenuArray[position] =  new DirectoryMenu(*this);
-  MenuItemArray[position]-&gt;set_submenu(*MenuArray[position]);
-  MenuForPath(position, path, ext);
-  MenuItemArray[position]-&gt;select();
-
-  needsRebuild[position] = true;
-
-  return true;
-
-  }
-
-/**********************/
-
-void Darimasen::DarimasenMenu:: selection_reset(guint position, Glib::ustring path){
-  if ( needsRebuild[position] ){
-    MenuItemArray[position]-&gt;remove_submenu();
-    delete MenuArray[position];
-    MenuArray[position] =  new DirectoryMenu(*this);
-    MenuItemArray[position]-&gt;set_submenu(*MenuArray[position]);
-    MenuForPath(position, path, &quot;&quot;);
-    MenuItemArray[position]-&gt;select();
-
-    needsRebuild[position] = false;
-    }
-}
-
-/**********************/
-
-//Decides the action of the menuItem, more sophisticated than the activate signal. 
-//its comment should always be somewhere.
-
-bool Darimasen::DarimasenMenu::DaMenuSelect(
-      GdkEventButton* event,
-      const Glib::ustring path,
-      guint pos,
-      bool first){
-
-  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 2) ) //middle
-  {
-  parent-&gt;newTab(path);
-  return true;
-  }
-  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 1) ) //left
-  {
-  parent-&gt;ChangeTab(pos,path,true,first);
-  return true;
-  }
-  if ((event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) ) //right
-  {
-    Gtk::Menu * m_Menu_Popup = Gtk::manage( new Gtk::Menu);
-    m_Menu_Popup-&gt;items().push_back( Gtk::Menu_Helpers::MenuElem(&quot;Open In new Tab&quot;));
-    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);
-  return true;
-   }
-
-  return false;
-
-  //DaFileLister(); //5:45pm, 24 Dec 2004, it worked! // leave this comment    
-  }
-
-/**********************/
-
-// provides the numbers by the arrows. 
-Glib::ustring Darimasen::DarimasenMenu::CountSubdir(const Glib::ustring&amp; path){
-  int j=0;
-  try{
-    Gnome::Vfs::DirectoryHandle handle;
-    handle.open(path, Gnome::Vfs::FILE_INFO_DEFAULT | Gnome::Vfs::FILE_INFO_FOLLOW_LINKS);
-
-    bool file_exists = true;
-    while(file_exists){
-
-      Glib::RefPtr&lt;Gnome::Vfs::FileInfo&gt; refFileInfo = handle.read_next(file_exists);
-      if (refFileInfo-&gt;get_type() == Gnome::Vfs::FILE_TYPE_DIRECTORY
-        &amp;&amp; ( (refFileInfo-&gt;get_name().substr(0,1) != &quot;.&quot;) || parent-&gt;optShowHidden-&gt;get_active())
-        &amp;&amp; refFileInfo-&gt;get_name() != &quot;.&quot;
-        &amp;&amp; refFileInfo-&gt;get_name() != &quot;..&quot;){
-        j++;
-        }
-      }
-    }
-  catch(const Gnome::Vfs::exception&amp; ex){}
-  return int2ustr(j);
-
-}
-
-/**********************/
-
-// parses the path, builds the menu bar. 
-Darimasen::DarimasenMenu::DarimasenMenu(const Glib::ustring &amp; path, Darimasen&amp; Myparent, guint pos){
-
-  depth = 0;
-
-  Glib::ustring shortpath = path; //home = getenv(&quot;HOME&quot;);
-  parent = &Myparent;
-  
-  int startPos = 0 , i = 0;
-
-
-  if ( path.find(getenv(&quot;HOME&quot;)) != Glib::ustring::npos ){
-    shortpath.replace(0,((Glib::ustring)getenv(&quot;HOME&quot;)).length(),&quot;~&quot;);
-    }
-
-  while ( (shortpath.find(slash,startPos) != Glib::ustring::npos) ) {
-    startPos = shortpath.find(slash,startPos) + 1; depth++;
-    }
-
-  menulevel =  new Glib::ustring[depth+1];
-  needsRebuild = new bool[depth+1];
-  for( int i=0; i&lt;=depth; i++)
-        needsRebuild[i] = false;
-
-
-  startPos = 0;
-  for(i = 0; shortpath.find(slash,startPos) !=  Glib::ustring::npos ; i++ ){
-    menulevel[i] = shortpath.substr(startPos,shortpath.find(slash,startPos) - startPos + 1 );
-    startPos = shortpath.find(slash,startPos) + 1;
-    };
-  menulevel[depth] = &quot;.&quot;;
-
-  MenuArray = new DirectoryMenu*[depth+1];
-  MenuItemArray = new Gtk::MenuItem*[depth+1];
-
-  for(int c = 0; c &lt; depth+1; c++){
-    MenuArray[c] =  new DirectoryMenu(*this);
-    }
- 
-    Glib::ustring subin = CountSubdir(path);
-    if ( subin != &quot;0&quot; ){
-      MenuItemArray[depth] =  new Gtk::MenuItem( subin + &quot; \342\226\272&quot; );
-      MenuItemArray[depth]-&gt;show();
-      MenuItemArray[depth]-&gt;set_submenu(*MenuArray[depth]);
-      prepend(*MenuItemArray[depth]);
-      MenuForPath(depth, path, &quot;&quot;);
-      }
-  
-  Glib::ustring crop = path;
-
-
-  for(i = depth - 1; i&gt;0; i--){
-    crop = crop.substr(0, crop.rfind(slash,crop.length()-2)) + slash;
-
-    MenuItemArray[i] = new Gtk::MenuItem(underscoreSafe(menulevel[i]) );
-    MenuItemArray[i]-&gt;show();
-    MenuItemArray[i]-&gt;set_submenu(*MenuArray[i]);
-    prepend(*MenuItemArray[i]);
-    MenuForPath(i, crop, &quot;&quot;);
-    }
-
-  MenuItemArray[i] = new Gtk::MenuItem(underscoreSafe(menulevel[i] ));
-  MenuItemArray[i]-&gt;show();
-  prepend(*MenuItemArray[i]);
-
-
-
-// root stuff
-    MenuItemArray[0]-&gt;set_submenu(*MenuArray[0]);
-    MenuItemArray[0]-&gt;show();
-    MenuArray[0]-&gt;show();
-
-    Gtk::MenuItem * subdir = Gtk::manage( new Gtk::MenuItem(&quot;/ (root)&quot;));
-    MenuArray[0]-&gt;attach(*subdir, 0 ,1, 0, 1);
-    subdir-&gt;show();
-
-          subdir-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                 &quot;/&quot;,pos,false));
-
-
-
-    Gtk::MenuItem * subdir2 = Gtk::manage( new Gtk::MenuItem(&quot;~ (home)&quot;));
-    MenuArray[0]-&gt;attach(*subdir2, 0 ,1, 1, 2);
-    subdir2-&gt;show();
-
-          subdir2-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-
-          subdir2-&gt;signal_button_press_event().connect(
-            sigc::bind&lt;Glib::ustring,guint,bool&gt;(
-              sigc::mem_fun(*this, &amp;Darimasen::DarimasenMenu::DaMenuSelect),
-                getenv(&quot;HOME&quot;),pos,false));
-
-    Gtk::SeparatorMenuItem * sep = Gtk::manage( new Gtk::SeparatorMenuItem());
-    MenuArray[0]-&gt;attach(*sep, 0 ,1, 2, 3);
-    sep-&gt;show();
-
-    Gtk::MenuItem * subdir3 = Gtk::manage( new Gtk::MenuItem(&quot;Add a location to this list&quot;));
-    MenuArray[0]-&gt;attach(*subdir3, 0 ,1, 3, 4);
-    subdir3-&gt;set_sensitive(false);
-    subdir3-&gt;show();
-
-
-  show();
-
-  }
-
-/**********************/
-
-// cleanup on asile 9. More might me Gtk::manageable...
-Darimasen::DarimasenMenu::~DarimasenMenu(){
-  for(int c = 0; c &lt; depth+1; c++){
-    delete MenuArray[c];
-    }
-  delete menulevel;
-  delete needsRebuild;
-  for (int i = 0; i &lt;=depth; i++){
-    delete MenuArray[i];
-    delete MenuItemArray[i];
-    }
-  
-  }
-
-/**********************/
-
 // anything prefixed with 'f' corresponds with a button. 'nuff said.
 void Darimasen::fNewTab(){
     std::stack&lt;Glib::ustring&gt; empty;
@@ -376,7 +42,7 @@
   DarimasenMenuContainer-&gt;remove();
 
  
-  DaMenu = Gtk::manage(new DarimasenMenu(history[n].top(), *this, n));
+  DaMenu = Gtk::manage(new class DarimasenMenu(history[n].top(), *this, n));
   DarimasenMenuContainer-&gt;add(*DaMenu);
 
   if (history[n].size() == 1)
@@ -462,8 +128,8 @@
 /**********************/
 
 // changing directories actually is making a new tab to substitute for the old one.
-void Darimasen::ChangeTab(guint nth, Glib::ustring pathin, bool addPath, bool menuOnly){
- // guint nth = Tabber-&gt;get_current_page();
+void Darimasen::ChangeCurrentPath(Glib::ustring pathin, bool addPath, bool menuOnly){
+  guint nth = Tabber-&gt;get_current_page();
 
   if (addPath &amp;&amp; !menuOnly){
     if (pathin.substr(pathin.length()-1) != &quot;/&quot;)
@@ -722,7 +388,7 @@
 void Darimasen::fBack(){
   history[Tabber-&gt;get_current_page()].pop();
 
-  ChangeTab(Tabber-&gt;get_current_page(),history[Tabber-&gt;get_current_page()].top(),false,false);
+  ChangeCurrentPath(history[Tabber-&gt;get_current_page()].top(),false,false);
 
   if (history[Tabber-&gt;get_current_page()].size() == 1)
     BackButton-&gt;set_sensitive(false);
@@ -755,31 +421,25 @@
 // this is called on file operations - since there is more then one tab,
 // all of them should be checked to see if they should be updated.
 void Darimasen::updateView(Glib::ustring sourceDir, Glib::ustring targetDir){
+//  std::cout &lt;&lt; sourceDir &lt;&lt; &quot;\n&quot; &lt;&lt; targetDir &lt;&lt; &quot;\n\n&quot;;
 
-  guint tmp = Tabber-&gt;get_current_page();
-
   for(int i = 0; i &lt; history.size(); i++){
     if( history[i].top() == sourceDir || history[i].top() == targetDir ){
-      ChangeTab(i,history[i].top(),false,false);
+      ChangeCurrentPath(history[i].top(),false,false);
       }
     }
-
-  Tabber-&gt;set_current_page (tmp);
 }
 
 /**********************/
 
-void Darimasen::fChangeIconMode(){
-  mode = (mode + 1) % 3; // increment, mod of possibilities.
+ void Darimasen::fChangeIconMode(){
+  mode = (mode + 1) % 2; // increment, mod of possibilities.
   std::cout &lt;&lt; &quot;mode = &quot; &lt;&lt; mode &lt;&lt; &quot;\n&quot;; 
 
-  guint tmp = Tabber-&gt;get_current_page();
+ // for(int i = 0; i &lt; history.size(); i++){
+ //     ChangeCurrentPath(history[i].top(),false,false);
+ //   } 
 
-  for(int i = 0; i &lt; history.size(); i++){
-      ChangeTab(i, history[i].top(),false,false);
-      } 
-
-  Tabber-&gt;set_current_page (tmp);
   }
 
 /**********************/

Modified: trunk/src/darimasen.h
===================================================================
--- trunk/src/darimasen.h	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/darimasen.h	2005-04-19 18:26:51 UTC (rev 56)
@@ -56,45 +56,14 @@
 #include &lt;gtkmm/layout.h&gt;
 
 #include &quot;iconmodes.h&quot;
+#include &quot;damenu.h&quot;
 
-
 /**********************/
 
 class Darimasen : public Gtk::Window {
-  class DarimasenMenu : public Gtk::MenuBar {
 
-    class DirectoryMenu : public Gtk::Menu {
-    public:
-      DirectoryMenu(DarimasenMenu&amp; in ){
-        Gtk::Menu::Menu();
-        }
-      };
+  //class DarimasenMenu;
 
-
-    Darimasen * parent;
-
-    int depth;
-
-    DirectoryMenu ** MenuArray; 
-    Gtk::MenuItem ** MenuItemArray;
-    Glib::ustring * menulevel;
-
-    void MenuForPath(int, Glib::ustring , Glib::ustring); //extension
-    bool SpecialMenuForPath(GdkEventButton* , int, Glib::ustring  , Glib::ustring); //extension
-
-    Glib::ustring CountSubdir(const Glib::ustring&amp;);
-    bool DaMenuSelect(GdkEventButton*, const Glib::ustring,guint,bool);
-    void selection_reset(guint, Glib::ustring);
- 
-    bool * needsRebuild;
-  public:
-
-    void signal_deactivate ();
-    DarimasenMenu(const Glib::ustring&amp;, Darimasen&amp;, guint);
-    ~DarimasenMenu();
-
-    };
-
   class aboutDa : public Gtk::Window {
     Gtk::Image * image1;
     Gtk::EventBox * closer;
@@ -109,7 +78,7 @@
   Gtk::VBox VerticalOrganizer;
   Gtk::Toolbar TopBar;
   Gtk::ToolItem * DarimasenMenuContainer;
-  DarimasenMenu * DaMenu;
+  class DarimasenMenu * DaMenu;
   Gtk::HPaned HideTreePane;
   Gtk::ScrolledWindow TreeScroller;
   Gtk::Notebook * Tabber;
@@ -130,10 +99,10 @@
 
 
   void fNewTab();
-  void newTab(Glib::ustring);
+
   void tabberSwitched(GtkNotebookPage*, guint);
   void addTab(guint);
-  void ChangeTab(guint, Glib::ustring, bool, bool);
+
   void removeTab(guint);
   void fBack();
   void fQuit();
@@ -146,17 +115,22 @@
 
   std::vector&lt; class DaIconModes* &gt; IconModeList;
   std::vector&lt; class Gtk::EventBox* &gt; EventBoxList;
+  short mode;
 
-
 public:
 
   Darimasen(std::vector&lt;Glib::ustring&gt;);
   ~Darimasen();
+
+  short get_mode(){return mode;}
+
   Gtk::CheckMenuItem * optShowHidden;
   void set_message(Glib::ustring);
   std::vector&lt; std::stack&lt;Glib::ustring&gt; &gt; history;
   void updateView(Glib::ustring, Glib::ustring);
-  short mode;
+
+  void newTab(Glib::ustring);
+  void ChangeCurrentPath(Glib::ustring path, bool, bool);
   };
 
 /**********************/

Modified: trunk/src/iconmodes.cpp
===================================================================
--- trunk/src/iconmodes.cpp	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/iconmodes.cpp	2005-04-19 18:26:51 UTC (rev 56)
@@ -8,14 +8,10 @@
 DaIconModes::DaIconModes(guint pos, Darimasen&amp; myParent) {    
 
   parent = &myParent;
-  position = pos;
-  mode = parent-&gt;mode;
 
-
-//Glib::RefPtr&lt;Gnome::Vfs::VolumeMonitor&gt; nx = Gnome::Vfs::VolumeMonitor::create();
-//Glib::ListHandle&lt; Glib::RefPtr&lt;Gnome::Vfs::Volume&gt; &gt; ny = nx-&gt;get_mounted_volumes();
+position = pos;
 
-  lastclick = 0;
+lastclick = 0;
   filesAtPath = 0;
   try{
     Gnome::Vfs::DirectoryHandle handle;
@@ -28,110 +24,57 @@
     }
   catch(const Gnome::Vfs::exception&amp;){std::cout &lt;&lt; &quot;Miscount?\n&quot;;}
 
+
+ // iconmode = 0;
+
+  slotsUsed = 0;
+  IconsHigh = 0;
   set_visible_window(false);
   hidden = new int[filesAtPath];
-
 
-      slotsUsed = 0;
-      IconsHigh = 0;
-
-  switch(mode){
-    case 0: // sidecon
-
-      sideconContainer = new Gtk::EventBox*[filesAtPath];
-      for(int c = 0; c &lt; filesAtPath; c++){
-        sideconContainer[c] = new Gtk::EventBox;
-        }
+  if(parent-&gt;get_mode() == 0){
+    sideconContainer = new Gtk::EventBox*[filesAtPath];
+    for(int c = 0; c &lt; filesAtPath; c++){
+      sideconContainer[c] = new Gtk::EventBox;
+      }
 
-      try {
-          // Call on_visit() for each file.
-          // The options specify that we want to visit the files at input_uri_string,
-          // get the mime type the fast way and protect against loops.
-        Gnome::Vfs::DirectoryHandle::visit( parent-&gt;history[position].top(), 
-           Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FORCE_FAST_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
-           Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
-           sigc::mem_fun(*this,&amp;DaIconModes::addEntry));
-        }
-      catch(const Gnome::Vfs::exception&amp; ex){/*this is required.*/}
-      break;
+    try {
+        // Call on_visit() for each file.
+        // The options specify that we want to visit the files at input_uri_string,
+        // get the mime type the fast way and protect against loops.
+      Gnome::Vfs::DirectoryHandle::visit( parent-&gt;history[position].top(), Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
+                                             Gnome::Vfs::FILE_INFO_FORCE_FAST_MIME_TYPE |
+                                             Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
+                                             Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
+                                             sigc::mem_fun(*this,&amp;DaIconModes::addEntry));
+      }
+    catch(const Gnome::Vfs::exception&amp; ex){/*this is required.*/}
+    }      
 
-    case 1: // List view
 
-      sideconContainer = new Gtk::EventBox*[filesAtPath];
-      for(int c = 0; c &lt; filesAtPath; c++){
-        sideconContainer[c] = new Gtk::EventBox;
-        }
 
-      try {
-        Gnome::Vfs::DirectoryHandle::visit( parent-&gt;history[position].top(), 
-           Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FORCE_FAST_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
-           Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
-           sigc::mem_fun(*this,&amp;DaIconModes::addEntry));
-        }
-      catch(const Gnome::Vfs::exception&amp; ex){/*this is required.*/}
-      break;
-
-    case 2: // Detail view
-      try {
-        m_Columns = new ModelColumns;
-        add(m_TreeView);
-        m_TreeView.show();
-        m_refTreeModel = Gtk::ListStore::create(*m_Columns);
-        m_TreeView.set_model(m_refTreeModel);
-
-
-        Gnome::Vfs::DirectoryHandle::visit( parent-&gt;history[position].top(), 
-           Gnome::Vfs::FILE_INFO_GET_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FORCE_FAST_MIME_TYPE |
-           Gnome::Vfs::FILE_INFO_FOLLOW_LINKS ,
-           Gnome::Vfs::DIRECTORY_VISIT_LOOPCHECK,
-           sigc::mem_fun(*this,&amp;DaIconModes::addEntry));
-
-
-
-  m_TreeView.append_column(&quot;Name&quot;, m_Columns-&gt;m_col_name);
-  m_TreeView.append_column(&quot;Size&quot;, m_Columns-&gt;m_col_size);
-  m_TreeView.append_column(&quot;Mime Type&quot;, m_Columns-&gt;m_col_mime);
-
-           m_TreeView.show_all_children();
-        }
-      catch(const Gnome::Vfs::exception&amp; ex){/*this is required.*/}
-      break;
-      }
-
-      
   }
 
 /**********************/
 
 DaIconModes::~DaIconModes(){
 
-// cleanup on aisles 1, 2, 3 ... and so on.
-
-  if(mode == 0 || mode == 1){
+  // cleanup on aisles 1, 2, 3 ... and so on.
+// there is an issue that this could be deleting while in the wrong mode - yeah.
+  if(parent-&gt;get_mode() == 0 ){
     for(int c = 0; c &lt; filesAtPath; c++){
       Gtk::Widget * tmp = sideconContainer[c]-&gt;get_child();
       if (tmp)
         delete tmp;
         }
 
-      for(int c = 0; c &lt; filesAtPath; c++){
-        delete sideconContainer[c];
-        }
-      delete sideconContainer;
-      delete hidden;
-    }
-  if(mode == 3){
-    delete m_Columns;
+    for(int c = 0; c &lt; filesAtPath; c++){
+      delete sideconContainer[c];
+      }
+    delete sideconContainer;
     delete hidden;
-    }
-
   }
-
+}
 /**********************/
 
 bool DaIconModes::addEntry(
@@ -141,60 +84,33 @@
     bool recurse) {
 
   if (info-&gt;get_type() != Gnome::Vfs::FILE_TYPE_DIRECTORY){
-    hidden[slotsUsed] = (info-&gt;get_name().substr(0,1) == &quot;.&quot;);
+      sideconContainer[slotsUsed]-&gt;set_visible_window(false);
+      sideconContainer[slotsUsed]-&gt;show();
 
-    switch(mode){
+hidden[slotsUsed] = (info-&gt;get_name().substr(0,1) == &quot;.&quot;);
 
-      case 0: 
-        sideconContainer[slotsUsed]-&gt;set_visible_window(false);
-        sideconContainer[slotsUsed]-&gt;show();
-        Sidecon * tempPathS = new Sidecon( parent-&gt;history[position].top(), info, *this);
-        tempPathS-&gt;show();
-        sideconContainer[slotsUsed]-&gt;add(*tempPathS);
-        sideconContainer[slotsUsed]-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-        sideconContainer[slotsUsed]-&gt;signal_button_press_event().connect(
-          sigc::bind&lt;Glib::ustring &gt;(
-            sigc::mem_fun(*this, &amp;DaIconModes::on_eventbox_button_press), info-&gt;get_name() ));
-        break;
+switch(parent-&gt;get_mode()){
+case 0: {
+Sidecon * tempPathS = new Sidecon( parent-&gt;history[position].top(), info, *this);
+      tempPathS-&gt;show();
+      sideconContainer[slotsUsed]-&gt;add(*tempPathS);
+	}
+break;
+case 1: {
+//Detail * tempPathD = new Detail(fullPath, info); 
+//      tempPathD-&gt;show();
+//     sideconContainer[slotsUsed]-&gt;add(*tempPathD);
+	}
+break;
+}
 
-      case 1: 
-        sideconContainer[slotsUsed]-&gt;set_visible_window(false);
-        sideconContainer[slotsUsed]-&gt;show();
-        ListIcon * tempPathL = new ListIcon( parent-&gt;history[position].top(), info, *this);
-        tempPathL-&gt;show();
-        sideconContainer[slotsUsed]-&gt;add(*tempPathL);
-        sideconContainer[slotsUsed]-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
-        sideconContainer[slotsUsed]-&gt;signal_button_press_event().connect(
-          sigc::bind&lt;Glib::ustring &gt;(
-            sigc::mem_fun(*this, &amp;DaIconModes::on_eventbox_button_press), info-&gt;get_name() ));
-        break;
-
-      case 2: 
-        Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
-
-        row[m_Columns-&gt;m_col_name] = info-&gt;get_name();
-
-
-        if( info-&gt;get_size() &lt; 1024 ){
-          row[m_Columns-&gt;m_col_size] = (&quot; &quot; + int2ustr(info-&gt;get_size()) + &quot; B&quot;);
-          }
-        else if ( info-&gt;get_size() &lt; (1024 * 1024) ){
-          row[m_Columns-&gt;m_col_size] = (&quot; &quot; + int2ustr(info-&gt;get_size() / 1024) + &quot; KB&quot;);
-          }
-        else{
-          row[m_Columns-&gt;m_col_size] = (&quot; &quot; + int2ustr(info-&gt;get_size() / 1048576) + &quot; MB&quot;);
-          }
-
-        row[m_Columns-&gt;m_col_mime] = info-&gt;get_mime_type();
-
-
-        break;
-
-      }
-
-    slotsUsed++;
+
+      sideconContainer[slotsUsed]-&gt;set_events(Gdk::BUTTON_RELEASE_MASK);
+      sideconContainer[slotsUsed]-&gt;signal_button_press_event().connect(
+        sigc::bind&lt;Glib::ustring &gt;(
+          sigc::mem_fun(*this, &amp;DaIconModes::on_eventbox_button_press), info-&gt;get_name() ));
+      slotsUsed++;
     }
-
   recurse = false; 
   return true;
   }
@@ -212,18 +128,19 @@
   if (info-&gt;get_name().length() &gt; 25){
     int last = info-&gt;get_name().rfind(&quot;.&quot;);
     if (last != -1){
-      FileName = new class Gtk::Label(
-        &quot; &quot; + info-&gt;get_name().substr(0, 20) + &quot;..&quot; + info-&gt;get_name().substr(last) );
+      FileName = new class Gtk::Label( info-&gt;get_name().substr(0, 20) + &quot;..&quot; + info-&gt;get_name().substr(last) );
       }
     else {
-      FileName = new class Gtk::Label( &quot; &quot; + info-&gt;get_name().substr(0,22) + &quot;...&quot; );
+      FileName = new class Gtk::Label( info-&gt;get_name().substr(0,22) + &quot;...&quot; );
       }
     }
   else {
-  FileName = new class Gtk::Label( &quot; &quot; + info-&gt;get_name() );
+  FileName = new class Gtk::Label( info-&gt;get_name() );
   }
                    
 
+
+//  FileName = new class Gtk::Label(shortnom);
   FileName-&gt;set_alignment(0,0.5);
   FileName-&gt;set_justify(Gtk::JUSTIFY_LEFT);
   attach(*FileName, 1, 2, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
@@ -235,7 +152,7 @@
 
 
   // this is where the mimetype info goes
-  FilePermissions = new class Gtk::Label(&quot; &quot; + info-&gt;get_mime_type());
+  FilePermissions = new class Gtk::Label(info-&gt;get_mime_type());
   FilePermissions-&gt;set_alignment(0,0.5);
   FilePermissions-&gt;set_justify(Gtk::JUSTIFY_LEFT);
   attach(*FilePermissions, 1, 2, 1, 2, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
@@ -243,13 +160,13 @@
 
   // This is simply file size - images an video could have more. Later.
   if( info-&gt;get_size() &lt; 1024 ){
-    FileSizeInfo = new class Gtk::Label(&quot; &quot; + int2ustr(info-&gt;get_size()) + &quot; B&quot;);
+    FileSizeInfo = new class Gtk::Label(int2ustr(info-&gt;get_size()) + &quot; B&quot;);
     }
   else if ( info-&gt;get_size() &lt; (1024 * 1024) ){
-    FileSizeInfo = new class Gtk::Label(&quot; &quot; + int2ustr(info-&gt;get_size() / 1024) + &quot; KB&quot;);
+    FileSizeInfo = new class Gtk::Label(int2ustr(info-&gt;get_size() / 1024) + &quot; KB&quot;);
     }
   else{
-    FileSizeInfo = new class Gtk::Label(&quot; &quot; + int2ustr(info-&gt;get_size() / 1048576) + &quot; MB&quot;);
+    FileSizeInfo = new class Gtk::Label( int2ustr(info-&gt;get_size() / 1048576) + &quot; MB&quot;);
     }
   FileSizeInfo-&gt;set_alignment(0,0.5);
   FileSizeInfo-&gt;set_justify(Gtk::JUSTIFY_LEFT);
@@ -257,50 +174,80 @@
 
 
   show_all_children();
  }
-/**********************/
+
+/**********************
 
-DaIconModes::Sidecon::~Sidecon(){
-  delete image1;
-  delete FileName;
-  delete FilePermissions;
-  delete FileSizeInfo;
-  }
+DaIconModes::Detail::Detail(
+    Glib::ustring path,
+    const Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt;&amp; info){
 
+
+  filePath = path + info-&gt;get_name();
 
-/**********************/
+  Glib::ustring shortnom = info-&gt;get_name();
 
-DaIconModes::ListIcon::ListIcon(
-      Glib::ustring path,
-      const Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt;&amp; info,
-      DaIconModes&amp; above){
+  if (info-&gt;get_name().length() &gt; 25){
+
+    int last = info-&gt;get_name().rfind(&quot;.&quot;);
 
-  parent = &above;
-  filePath = path + info-&gt;get_name();
+    if (last != -1){ //fix for the missing extension bug
+      Glib::ustring ext = info-&gt;get_name().substr(last);  
+      shortnom = info-&gt;get_name().substr(0, 20) + &quot;..&quot; + ext;
+      }
+    else {
+      shortnom = info-&gt;get_name().substr(0,22) + &quot;...&quot;;
+      }
+
+    }
+                   
+  resize(1,3);
+  //Gtk::Image * image1 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-dnd&quot;), Gtk::IconSize(6)));
+  Gtk::Label * FileName = Gtk::manage(new class Gtk::Label(shortnom));
 
-  FileName = new class Gtk::Label( &quot; &quot; + info-&gt;get_name() );
+  // this is where the mimetype info goes
+  mimeInfo = info-&gt;get_mime_type();
+  Gtk::Label * FilePermissions = Gtk::manage( new class Gtk::Label(mimeInfo));
 
-  FileName-&gt;set_alignment(0,0.5);
-  FileName-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-  attach(*FileName, 1, 2, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+  // THis is simply file size - images an video could have more. Much later.
+  Glib::ustring size;
+  if( info-&gt;get_size() &lt; 1024 ){
+    size = int2ustr(info-&gt;get_size()) + &quot; B&quot;;
+    }
+  else if ( info-&gt;get_size() &lt; (1024 * 1024) ){
+    size = int2ustr(info-&gt;get_size() / 1024) + &quot; KB&quot;;
+    }
+  else{
+    size = int2ustr(info-&gt;get_size() / 1024 / 1024) + &quot; MB&quot;;  std::cout &lt;&lt; &quot;2\n&quot;;
+    }
 
-
-  // hand off getting the icon
-  image1 = new class Gtk::Image(parent-&gt;getIcon(info-&gt;get_mime_type(), 16));
-  attach(*image1, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+  // ideally, this label would be 80% size of standard
+  Gtk::Label * FileSizeInfo = Gtk::manage( new class Gtk::Label(size));
 
-  show_all_children();
  }
-/**********************/
-
-DaIconModes::ListIcon::~ListIcon(){
-  delete image1;
-  delete FileName;
-  }
+  FileName-&gt;set_alignment(0,0.5);
+  FileName-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+  FilePermissions-&gt;set_alignment(0,0.5);
+  FilePermissions-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+  FileSizeInfo-&gt;set_alignment(0,0.5);
+  FileSizeInfo-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+  
+  //attach(*image1, 0, 1, 0, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+  attach(*FileName, 0, 1, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+  attach(*FilePermissions, 1, 2, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+  attach(*FileSizeInfo, 2, 3, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+  
+  //image1-&gt;show();
+  FileName-&gt;show();
+  FilePermissions-&gt;show();
+  FileSizeInfo-&gt;show();
+  show();
  }
 
 /**********************/
 
+
 void DaIconModes::RunFile(const Glib::ustring file) {
 
   // see if the file is executable 
+
   Gnome::Vfs::Handle read_handle;
   Gnome::Vfs::Handle exec_handle;
   Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt; info;
@@ -530,24 +477,30 @@
 
 void DaIconModes::on_size_allocate(Gtk::Allocation&amp; allocation){
 
-  int oldie = IconsHigh;
-  switch (mode){
-    case 0:
-      IconsHigh = allocation.get_height() / 57;
-      if ( oldie != IconsHigh ){
-        redraw(); // if resize is needed
-        }
-      break;
 
-    case 1:
-      IconsHigh = allocation.get_height() / 25;
-      if ( oldie != IconsHigh ){
-        redraw(); // if resize is needed
-        }
-      break;
+  if(parent-&gt;get_mode() == 0){
+    int oldie = IconsHigh;
+    IconsHigh = allocation.get_height() / 58;
+  
+    if ( oldie != IconsHigh ){
 
+redraw(); // if resize is needed
+     
+      }
     }
 
+
+  if(parent-&gt;get_mode() == 1 ){
+   
+    Gtk::Widget * tmp = get_child();
+if (!tmp){
+    IconsHigh = 0;
+    if (tmp)
+      delete tmp; // actually DisposableTable, but segfaulted otherwise
+    Gtk::Label * x = new Gtk::Label(&quot;Details go here.&quot;);
+    x-&gt;show();
+    add(*x);
+    }}
   Gtk::EventBox::on_size_allocate(allocation);
   }
 
@@ -558,7 +511,7 @@
   
    if (tmp)
         delete tmp; // actually DisposableTable, but segfaulted otherwise
-      Gtk::Table * DisposableTable = new Gtk::Table;//((filesAtPath)/IconsHigh+1,IconsHigh);
+      Gtk::Table * DisposableTable = new Gtk::Table((filesAtPath)/IconsHigh+1,IconsHigh);
       add(*DisposableTable);
       int y_pos = 0;
       int x_pos = 0;
@@ -570,7 +523,7 @@
               Gtk::FILL, Gtk::FILL, 4, 4);
           sideconContainer[i]-&gt;show();
           y_pos++; 
-          if(mode == 0 || mode == 1){
+          if(parent-&gt;get_mode() == 0){
             if ( y_pos + 1 &gt; IconsHigh){
               y_pos = 0;
               x_pos++;
@@ -933,6 +886,7 @@
     ico = &quot;/usr/share/icons/gnome/48x48/mimetypes/gnome-mime-&quot;;
     ico += mimeGiven.replace(mimeGiven.find(&quot;/&quot;), 1, &quot;-&quot;);
     ico += &quot;.png&quot;;
+
     Glib::file_get_contents(ico);
     }
   catch(const Glib::Error) {

Modified: trunk/src/iconmodes.h
===================================================================
--- trunk/src/iconmodes.h	2005-04-15 06:00:18 UTC (rev 55)
+++ trunk/src/iconmodes.h	2005-04-19 18:26:51 UTC (rev 56)
@@ -15,23 +15,12 @@
 #include &quot;darimasen.h&quot;
 #include &lt;gtkmm/separator.h&gt;
 #include &lt;unistd.h&gt;
-#include &lt;gtkmm/liststore.h&gt;
 
 /**********************/
 
 class DaIconModes : public Gtk::EventBox {
 
-  class ListIcon : public Gtk::Table {
-    Glib::ustring filePath, mimeInfo;
-    DaIconModes * parent;
-    Gtk::Image * image1;
-    Gtk::Label * FileName;
-  public:
-    ListIcon(Glib::ustring, const Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt;&amp;, DaIconModes&amp;);
-    ~ ListIcon();
-    };
 
-
   class Sidecon : public Gtk::Table {
     Glib::ustring filePath, mimeInfo;
     DaIconModes * parent;
@@ -41,28 +30,23 @@
     Gtk::Label * FileSizeInfo;
   public:
     Sidecon(Glib::ustring, const Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt;&amp;, DaIconModes&amp;);
-    ~Sidecon();
+    ~Sidecon(){
+      delete image1;
+      delete FileName;
+      delete FilePermissions;
+      delete FileSizeInfo;
+      }
+
     };
 
-  class ModelColumns : public Gtk::TreeModel::ColumnRecord {
-  public:
+/*
+  class Detail : public Gtk::Table {
+    public:
+    Glib::ustring filePath, mimeInfo;
+    Detail(Glib::ustring, const Glib::RefPtr&lt;const Gnome::Vfs::FileInfo&gt;&amp; );
+    };
+*/
 
-    ModelColumns(){
-     // add(m_col_icon);
-      add(m_col_name);
-      add(m_col_size);
-      add(m_col_mime);
-      }
-
-    //Gtk::TreeModelColumn&lt;Gdk::Pixmap* &gt; m_col_icon;
-    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
-    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_size;
-    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_mime;
-  };
-
-
-
-
   class ChooseActionDialogue : public Gtk::Dialog {
     Gtk::RadioButton::Group _RadioBGroup_radiobutton1;
     Gtk::Button *cancelbutton1, *okbutton1;
@@ -204,10 +188,6 @@
 
   Gtk::EventBox ** sideconContainer;
 
-  ModelColumns * m_Columns;
-  Gtk::TreeView m_TreeView;
-  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;
-
   Gtk::Menu m_Menu_Popup;
 
 
@@ -218,7 +198,7 @@
   guint position;
   guint filesAtPath;
   int * hidden;
-  short mode;
+
 
 public:
   ~DaIconModes();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000008.html">[Darimasen-svn] r55 - trunk/src
</A></li>
	<LI>Next message: <A HREF="000010.html">[Darimasen-svn] r57 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/darimasen-svn">More information about the Darimasen-svn
mailing list</a><br>
</body></html>
